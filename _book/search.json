[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "",
    "text": "Johdanto\nTämä materiaali on suunniteltu käytettäväksi Jyväskylän yliopiston kurssilla Tilastolliset Ohjelmistot sekä Itä-Suomen yliopiston R-kurssilla. Materiaali toimii R-ohjelmoinnin harjoittelun tukena.\nAnton Klåvusin vuonna 2020 kirjoittamaa ansiokasta materiaalia on kehitetty lukukauden 2021-22 R-kielen kurssia ajatellen. Materiaalia on täydennetty tarvittavin osin ja amalla materiaali on muunnettu verkkokirjamuotoon. Tämä opiskelumateriaali on luotu Quarto-julkaisujärjestelmän avulla . Kirjaa voi lukea verkkoselaimella ja se toimii myös puhelimella.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "index.html#lunttilappu",
    "href": "index.html#lunttilappu",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "Lunttilappu",
    "text": "Lunttilappu\nTämän materiaalin ohessa kannattaa käyttää apuna nk. Cheat Sheetiä eli “lunttilappua”. Lunttilapusta on helppo tarkastaa miten jokin jo oppimasi asia tehdään R:ssä, jos et vielä muista kunnolla kyseistä asiaa. Internetistä löytyy Cheat Sheetejä useisiin R-paketteihin ja muihin kokonaisuuksiin, mutta tässä käytetään Base R Cheat Sheetiä. Lataa Base R Cheat Sheet itsellesi painamalla tästä.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "index.html#verkkolähteitä",
    "href": "index.html#verkkolähteitä",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "Verkkolähteitä",
    "text": "Verkkolähteitä\nTämä materiaali on tarkoitettu riittäväksi materiaaliksi kurssille. Tässä kuitenkin joitakin verkosta löytyviä lähteitä, joista voi olla apua.\n\nTutorialspoint Soveltuu R:n opiskeluun englannin kielellä, jos osaa entuudestaan jo vähän ohjelmoida.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "index.html#alkuvalmistelut",
    "href": "index.html#alkuvalmistelut",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "Alkuvalmistelut",
    "text": "Alkuvalmistelut\n\nRStudio\nRStudio on ohjelmointiympäristö eli IDE (Integrated Development Environment), joka tekee koodaamisesta huomattavasti mukavampaa. RStudio on saatavilla useille käyttöjärjestelmille ja se on ilmainen ohjelma. Tässä kirjassa oletetaan, että käytössä on RStudio, mutta muutkin ympäristöt ovat sopivia.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "index.html#rn-ja-rstudion-asentaminen-omalle-tietokoneelle",
    "href": "index.html#rn-ja-rstudion-asentaminen-omalle-tietokoneelle",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "R:n ja RStudion asentaminen omalle tietokoneelle",
    "text": "R:n ja RStudion asentaminen omalle tietokoneelle\nMene seuraavalle sivulle, josta asennat ensin R:n (1. vaihe) ja sitten RStudio Desktop omalle käyttöjärjestelmällesi. Ellet tiedä käyttöjärjestelmääsi, on se luultavimmin Windows 10.\nhttps://www.rstudio.com/products/rstudio/download/#download (avautuu uuteen ikkunaan)\n\nRStudion asennus yliopiston koneelle\nMikäli et halua käyttää omaa tietokonettasi kurssin suoritamiseen, niin RStudion saa asennettua UEF:in koneilla Sofware Centerin kautta. Software Center löytyy Windowsin omalla haulla.\n\nRStudio:n voi asentaa Software Centeristä, ja RStudion pitäisi sen jälkeen olla käytettävissä. Tyypillisesti R ja RStudio ovat valmiiksi asennettuna\n\n\n\nRStudion käyttö\nRStudion näkymässä on neljä osaa:\n\n\n1. Editori.\nEditorilla kirjoitetaan R-koodia sisältäviä tiedostoja, eli R-skriptejä. Uuden skriptin saa auki painamalla File -&gt; New File -&gt; R Script (tai Ctrl + Shift + N). Skripteihin tutustutaan myöhemmin kurssilla, mutta ne ovat yksinkertaisuudessaan kokoelma R-komentoja, jotka yhdessä tekevät jotain, esimerkiksi analysoivat jonkin tutkimusprojektin datan tai piirtävät valmiista tuloksista kuvaajia.\nEditoriin kirjoitettua koodia voi ajaa rivi kerrallaan painamalla rivin kohdalla Ctrl + Enter. Useamman rivin voi myös maalata ja suorittaa kerrallaan. Yläreunassa oleva “Source”-nappi ajaa kaiken nykyisen tiedoston koodin.\nR-skriptejä voi tallentaa ihan kuin muitakin tiedostoja. R-skpriptien tiedostopääte on .R. Kaikki harjoitustehtävissä ja loppukokeessa käyttämäsi koodi on syytä kirjoittaa skripteihin. Kun tehtävät tallentaa tällä tavalla, voi ensi kerralla vain yksinkertaisesti ajaa skriptin haluamaansa tehtävään asti.\n\n\n2. Konsoli.\nKonsolissa “ajetaan” eli suoritetaan R-komentoja. Jos editoriin kirjoitettua koodia ajetaan, RStudio ajaa komennot automaattisesti konsolissa. Konsolissa pelkkä Enter riittää koodirivin suorittamiseen. Voit kokeilla kirjoittaa konsoliin jonkun laskutoimituksen, kuten 2 * 3 ja painaa Enter, jolloin tuloksen pitäisi tulostua konsoliin. Voit myös kokeilla kirjoittaa laskuja editoriin, ja painaa Ctrl + Enter, jolloin pitäisi tapahtua sama asia. Konsoliin tulostuvat myös mahdolliset viestit, varoitukset ja virheilmoitukset.\nSuurin ero konsolin ja editorin välillä on se, että konsoliin kirjoitetut komennot eivät tallennu mihinkään tiedostoon. Jos siis haluat säilyttää koodisi, se tulee kirjoittaa editoriin ja tallentaa .R-tiedostoon. Saman istunnon aikana tehtyjä komentoja voi konsolissa selata ylös- ja alas-nuolila.\nMoodlen ohjeissa ja videoissa käytetään R:ää puhtaasta R-konsolista. Voit siis kuvitella, että kurssin videoissa näkyy vain RStudion tämä osa, ja muut osat ovat vain helpottamassa työtäsi.\n\n\n3. Työtila\nTyötilassa näkyvät R-istunnon aikana luodut muuttujat.\n\n\n4. Tiedostot / Kuvaajat / Paketit / Manuaali\nTässä osassa on monta käytännöllistä välilehteä:\n\nFiles: Näyttää käyttöjärjestelmän hakemistorakenteen, oletusarvoitesti työhakemiston.\nPlots: Tänne ilmestyvät R:llä piirretyt kuvaajat.\nPackages: Täältä voi hallita asennettuja paketteja (alla ohjeet tällä kurssilla tarvittavien pakettien asennukseen).\nHelp: Täällä voi selata R:n manuaalia, jossa on ohjeet jokaiselle R-komennolla. Voit kokeilla ajaa editorissa tai konsolissa komennon ?print, joka avaa print-funktion ohjesivun.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "index.html#rcourse-paketin-asentaminen",
    "href": "index.html#rcourse-paketin-asentaminen",
    "title": "Tilastolliset Ohjelmistot: R",
    "section": "Rcourse-paketin asentaminen",
    "text": "Rcourse-paketin asentaminen\n\nR-paketit\nR-ohjelmoinnissa asennetaan usein R-paketteja. Paketit ovat kokonaisuuksia, jotka lisäävät R:ään ominaisuuksia. Esimerkiksi tällä kurssille tarvittava paketti Rcourse sisältää harjoitustehtäviä kurssin aihepiireistä sekä loppukokeen, jonka perusteella kurssin suoritus arvioidaan.\n\n\nAsentaminen\nRcourse-paketti asennetaan suorittamalla seuraava koodi R:ssä. Kopioi koodi joko R-skriptiin ja aja se tai kopioi se suoraan Console-ikkunaan ja paina Enter-näppäintä.\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"santikka/R-course\")\n\nTämän jälkeen paketti tulee ottaa käyttöön\n\nlibrary(\"Rcourse\")\n\nKomento info() tulostaa paketin ohjeet (ensimmäisellä käyttökerralla kieli on englanti). Voit vaihtaa kielen suomeksi näin:\n\nselect_language(\"finnish\")\n\nJos haluat, että kielivalinta säilyy R-istunnosta toiseen, tulee asettaa seuraava argumentti:\n\nselect_language(\"finnish\", save_selection = TRUE)\n\nHuomaa, että kielen vaihtuessa myös joidenkin pakettiin liittyvien funktioiden nimet vaihtuvat. Tarkastele vielä suomenkielisiä komentoja:\n\nohje()\n\n\nAloita sitten osion 1 harjoitustehtävien suorittaminen komennolla\n\nosio(1)\n\nKun olet suorittanut harjoitusosion 1, voit jatkaa seuraavaan osioon. Osiot 1-7 ovat pakollisia (tentit kysyvät näiden osioiden sisältöjä) ja osiot 8-11 ovat lisämateriaalia kiinnostuneille (ei kysytä tentissä).\n\n\nOpiskelu ja tenttiminen Rcourse-paketin avulla\nKurssin harjoitustehtävät suoritetaan käyttäen Rcourse-pakettia, eli 1. osion voi aloittaa komennolla\n\nosio(1)\n\nLisäksi tenttiminen onnistuu vastaavasti funktiolla loppukoe(x), mutta tällöin merkin x tilalle on annettava oma syntymäaika muodossa “dd/mm/yyyy”. Esim. henkilö joka on syntynyt 1. tammikuuta 1990 antaisi\n\nloppukoe(\"01/01/1990\")\n\n\n\nTehtävien tallentaminen skripteihin RStudiolla\nSuurin osa kurssin tehtävistä on melko lyhyitä, joten ne voi tarvittaessa tehdä suoraan konsoliin. On kuitenkin suositeltavaa kirjoittaa varsinkin pidemmät ja monimutkaisemmat tehtävät muistiin skriptitiedostoon. Jokaista osiota varten kannattaa tehdä erillinen R-skripti, joka sisältää tehtävien tarvitseman koodin sekä palautuskomennot. Tällainen skripti näyttää jotakuinkin tältä:\n\n# Teht 1\nvast &lt;- 1\nvastaa(vast)\n\n# Teht 2\nvast &lt;- c(1, 2, 3)\nvastaa(vast)\n\n# Teht 3\nvast &lt;- \"jotain\"\nvastaa(vast)\n\nMikäli käytät nimen vast sijasta jotain muuta nimeä, niin sinun on käytettävä samaa nimä myös vastaa-funktion argumenttina! Huomaa, että tehtäviin vastataan aina syöttämällä R-objekti, paitsi kuvien piirtämistä käsittelevässä osiossa.",
    "crumbs": [
      "Johdanto"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  R",
    "section": "",
    "text": "1.1 Mikä R on ja mitä sillä tehdään?\nR on tehty ensisijaisesti tilastotiedettä ja data-analyysiä varten. R:llä kirjoitetaan yleensä lyhyitä ohjelmia, joita kutsutaan skripteiksi. R:llä ei siis ole tarkoitus kehittää esimerkiksi pelejä, tai muita ohjelmia joissa on graafinen käyttöliittymä, kuten vaikkapa Photoshop. R ei myöskään ole web-ohjelmointiin tarkoitettu kieli (vaikka oikeilla paketeilla R:lläkin pystyy tekemään web-sovelluksia).\nR on korkean tason ohjelmointikieli. Tämä tarkoittaa sitä, että R:ssä on paljon valmiita komentoja, joiden “alta” löytyy paljon lisää koodia, johon R-ohjelmoijan ei kuitenkaan tarvitse itse koskea. Esimerkiksi tilastollinen t-testi vaatii useita matemaattisia välivaiheita, mutta R-ohjelmoija voi suorittaa testin yhdellä komennolla (t.test), joka antaa kaikki tarvittavat tiedot testistä.\nR:n käyttöä ja ohjelmointia oppii parhaiten tekemällä. Tässä dokumentaatiossa on tekstin väliin upotettu R-koodia harmaissa laatikoissa, kuten alla olevassa esimerkissä. Koodin alla esiintyy usein myös koodin ajamisen aiheuttamia tulosteita (output) tekstin seassa. Otetaan ensimmäiseksi esimerkiksi klassinen “Hello, world!”-komento:\nprint(\"Hello, world!\")\n\n[1] \"Hello, world!\"\nprint-funktio tulostaa sille annetun tekstin konsoliin ja se on kätevä funktio mm. ohjelman toiminnan testaamiseen ja pidemmän ohjelman etenemisen seurantaan.\nR:ää voi käyttää myös laskimen sijaan. Alla olevassa esimerkissä lasketaan kuinka paljon jää hintaa 80 euron hintaiselle tuotteelle 35% alennuksen jälkeen.\n80 * (1 - 0.35)\n\n[1] 52\nYksittäisten komentojen ajamisesta ei kuitenkaan ole yleensä hyötyä, ellei tuloksia voi tallentaa johonkin. Ohjelmointikielissä tietoja tallennetaan muuttujiin, joita käsitellään seuraavaksi.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R</span>"
    ]
  },
  {
    "objectID": "02-variables.html",
    "href": "02-variables.html",
    "title": "2  Muuttujat ja vektorit",
    "section": "",
    "text": "2.1 Muuttujat\nMuuttujat (variables) ovat yksi tärkeimmistä ohjelmointikielien rakenteista. Muuttujien tehtävä on säilyttää tietoa ja tuloksia edellisistä laskutoimituksista. Alla on yksinkertainen esimerkki muuttujien käytöstä R:ssä.\nx &lt;- 3\ny &lt;- 5\nz &lt;- x + y\nz\n\n[1] 8\nEdellisessä esimerkissä sijoitetaan (assign) eli tallennetaan muuttujaan x arvo 3 ja muuttujaan y arvo 5. Sen jälkeen muuttujien x ja y summa sijoitetaan muuttujaan z, jonka jälkeen tulostetaan muuttujan z arvo. Symboli &lt;- on R:n sijoitusoperaattori (myös yhtä kuin-merkki = toimii melkein aina, mutta &lt;- merkin käyttöä suositellaan vahvasti). Sijoitusoperaattori kertoo R:lle, että symbolin &lt;- vasemmalle puolelle sijoitetaan sen oikean puolen laskutoimituksen tulos. Vasen puoli määrittää muuttujan nimen\nMutta miten muuttujan z arvo tulostui konsoliin, vaikka koodissa ei käytetty funktiota print? R:n erikoisominaisuus moneen muuhun ohjelmointikieleen verrattuna on se, että print-käskyä ei tarvitse aina kirjoittaa, vaan pelkästään muuttujan (tai laskutoimituksen) kirjoittaminen tulostaa arvon konsoliin, kuten alla oleva koodi havainnollistaa:\nz\nprint(z)\n\nx + y\nprint(x + y)\n\n3 + 5\nprint(3 + 5)\nMuuttujiin voi sijoittaa muutakin kuin yksittäisiä lukuja, kuten merkkijonoja (strings), vektoreita, tai paljon monimutkaisempiakin rakenteita.\nx &lt;- \"Hello world\"\nx\n\n[1] \"Hello world\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Muuttujat ja vektorit</span>"
    ]
  },
  {
    "objectID": "02-variables.html#kommentit",
    "href": "02-variables.html#kommentit",
    "title": "2  Muuttujat ja vektorit",
    "section": "2.2 Kommentit",
    "text": "2.2 Kommentit\nMyöhemmin vastaan tulevassa koodissa käytetään kommentteja. Kommentit ovat koodin oheen kirjoitettua tekstiä, joka ei ole ohjelmointikieltä, ja joka ohitetaan koodia ajettaessa. Kommenttien tarkoitus on kuvailla koodin toimintaa. Oman koodin kommentointia on hyvä harjoitella alusta lähtien, vaikka ensimmäisten tehtävien koodi onkin hyvin yksinkertaista. R:ssä kommentit merkataan #-symbolilla. Edellinen esimerkki kommentoituna voisi näyttää jotakuinkin tältä:\n\n# Assign arbitrary numbers to two variables\nx &lt;- 3\ny &lt;- 5\n# Sum of two variables\nz &lt;- x + y\n# Print the results\nz\n\n[1] 8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Muuttujat ja vektorit</span>"
    ]
  },
  {
    "objectID": "02-variables.html#vectors",
    "href": "02-variables.html#vectors",
    "title": "2  Muuttujat ja vektorit",
    "section": "2.3 Vektorit",
    "text": "2.3 Vektorit\nNyt kun muuttujat ovat tuttuja, voimme siirtyä käsittelemään vektoreita (vector). R:n vektorit ovat yksinkertaisia järjestettyjä tietorakenteita, jotka koostuvat alkioista (elements), esimerkiksi desimaaliluvuista. Alla oleva esimerkki sijoittaa muuttujaan x vektorin, joka sisältää 5 lukua.\n\nx &lt;- c(1, 2, 7.4, 15, 0.2)\nx\n\n[1]  1.0  2.0  7.4 15.0  0.2\n\n\nYksinkertaisin tapa tehdä vektori R:ssä on käyttää c-funktiota, joka luo vektorin, joka sisältää sille annetut arvot annetussa järjestyksessä. Monet R-kielen komennot ja funktiot luovat vektoreita, alla muutama esimerkki:\n\n# Regular sequences\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 1, by = 0.2)\n\n[1] 0.0 0.2 0.4 0.6 0.8 1.0\n\nseq_len(6)\n\n[1] 1 2 3 4 5 6\n\n3:9\n\n[1] 3 4 5 6 7 8 9\n\n# Repeat values\nrep(1, 5)\n\n[1] 1 1 1 1 1\n\n# Repeat vector c(1, 2) 3 times\nrep(c(1, 2), 3)\n\n[1] 1 2 1 2 1 2\n\n# Repeat all values in vector c(1, 2, 3) 3 times\nrep(c(1, 2, 3), 3) \n\n[1] 1 2 3 1 2 3 1 2 3\n\n\n\n2.3.1 Vektorilaskentaa\nVektoreilla laskeminen on usein hyvin intuitiivista (lisää vaaranpaikoista myöhemmin). Kun vektoriin kohdistetaan laskutoimintoja, sama operaatio tehdään kaikille vektorin alkioille. Kyseessä on ns. vektorisaatio (engl. vectorization).\n\nx &lt;- c(1, 2, 3, 6, 10)\nx * 2\n\n[1]  2  4  6 12 20\n\nx / 2 + 1\n\n[1] 1.5 2.0 2.5 4.0 6.0\n\n\nEntä jos vektoreita lisää toisiinsa, tai kertoo keskenään? Jos vektorit ovat samanpituisia, operaatio toteutetaan alkio kerrallaan. Jos vektorit ovat eripituisia, R yrittää kierrättää (recycle) lyhyempää vektoria niin, että siitä tulee yhtä pitkä kuin pidempi vektori. Tämän jälkeen operaatio suoritetaan alkio kerrallaan (itse asiassa näin tapahtui myös aiemmissa esimerkeissä, kun vektori kerrottiin yksittäisellä luvulla. R:ssä yksittäiset luvut ovat vektoreita, joiden pituus on 1). Jos kierrätys ei onnistu, eli pidemmän vektorin pituus ei ole jaollinen lyhyemmän pituudella, R antaa virheilmoituksen.\n\nx &lt;- c(1, 2, 3, 6, 10, 2)\ny &lt;- c(1, 1, 1, 3, 3, 3) # or rep(c(1, 3), each = 3)\nz &lt;- c(2, 4)\n\nx + y # Element-wise sum\n\n[1]  2  3  4  9 13  5\n\nx * y # Element-wise multipliocation\n\n[1]  1  2  3 18 30  6\n\nx + z\n\n[1]  3  6  5 10 12  6\n\n\nR:ssä on myös paljon funktioita, joilla voi laskea vektoreista erilaisia tunnuslukuja, kuten keskiarvon, mediaanin, keskihajonnan jne.\n\nx &lt;- c(1, 2, 3, 6, 10, 2)\n# Sample mean (average)\nmean(x)\n\n[1] 4\n\n# Standard deviation\nsd(x)\n\n[1] 3.405877\n\n# Sum\nsum(x)\n\n[1] 24\n\n\n\n\n2.3.2 Ei-numeeriset vektorit\n\n2.3.2.1 Merkkijonovektorit\nVektorien ei ole pakko sisältää lukuja. Vektorit voivat sisältää esimerkiksi merkkijonoja, kuten alussa nähty “Hello, world!”. Merkkijonotyypin nimi R:ssä on character.\n\nx &lt;- c(\"Hello, world!\", \"R is the best\", \"I\", \"like\", \"programming\", \"!\")\nx\n\n[1] \"Hello, world!\" \"R is the best\" \"I\"             \"like\"         \n[5] \"programming\"   \"!\"            \n\n\nMerkkijonovektoreiden muokkausta varten on omia funktiota, tärkeimpinä paste ja paste0, jotka yhdistävät merkkijonoja toisiinsa. Myös numeerisia vektoreita voi antaa näille funktioille, ja ne muutetaan merkkijonoiksi.\n\nfirst_names &lt;- c(\"Diana\", \"Peter\", \"Bruce\")\nlast_names &lt;- c(\"Prince\", \"Parker\", \"Wayne\")\npaste(first_names, last_names)\n\n[1] \"Diana Prince\" \"Peter Parker\" \"Bruce Wayne\" \n\nstudents &lt;- paste0(\"Student_\", 1:5)\n\n\n\n2.3.2.2 Loogiset vektorit\nKolmas yleinen vektorityyppi on looginen vektori, joka sisältää arvoja TRUE eli tosi tai FALSE eli epätosi. Loogisia vektoreita käytetään yleensä joko merkitsemään binäärisiä muuttuja (esimerkiksi paastosiko koehenkilö ennen näytteenottoa) tai vektorien ja matriisien indeksoinnissa (tästä lisää pian). Tällöin loogisia vektoreita syntyy erilaisten loogisten operaattorien avulla:\n\nx &lt;- c(1, 2, 3, 6, 10, 2)\n\nx &gt; 3 # Is the element of x greater than 3?\n\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE\n\nx &gt;= 3 # Greater or equal to three=\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE FALSE\n\nx == 6 # Equal to 6?\n\n[1] FALSE FALSE FALSE  TRUE FALSE FALSE\n\nx != 2 # Not equal to 2?\n\n[1]  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n\n\n\n\n2.3.2.3 Loogiset vektorit ja matematiikka\nJos loogiselle vektorille tekee operaation, joka odottaa numeerista vektoria, R muuttaa automaattisesti arvot TRUE ykkösiksi ja arvot FALSE nolliksi. Tämä on erityisen hyödyllistä käytettäessä funktiota sum. Tällä tavalla saadaan helposti tietää esim. kuinka moni vektorin alkio täyttää tietyn ehdon:\n\nx &lt;- c(1, 3, 5, 2, 19)\nabove_3 &lt;- x &gt; 3\n\n# Logical vector automatically converted to numeric\nx + 1\n\n[1]  2  4  6  3 20\n\n# how many elements of x are smaller than 10?\nsum(x &lt; 10)\n\n[1] 4\n\n\n\n\n\n2.3.3 Vektorien indeksointi ja osajoukon valinta\nUsein vektorista halutaan poimia vain tietyt arvot, esimerkiksi vain ensimmäiset 5 arvoa, tai vain arvot, jotka täyttävät tietyt ehdot. R:ssä vektorin indeksointiin käytetään hakasulkeita []. Yleisin indeksointitapa on antaa hakasulkeiden sisään vektori kokonaislukuja, jotka vastaavat niiden alkioiden järjestyslukuja, jotka vektorista halutaan poimia (HUOM R:ssä indeksointi alkaa ykkösestä, ei nollasta!). Toinen vaihtoehto on käyttää loogista vektoria, jolloin vektorista poimitaan ne alkiot, joiden kohdalla loogisen vektorin arvo on TRUE. Tämä on yksinkertaisempaa kuin miltä se kuulostaa:\n\nx &lt;- c(1, 2, 3, 6, 10, 2)\n\n# Picking exact elements\nx[2:3] # Second and third values\n\n[1] 2 3\n\nx[c(4, 5, 1)] # Note that the order does not have to be increasing\n\n[1]  6 10  1\n\n# Using logical vector as condition\nx[x &gt; 3]\n\n[1]  6 10\n\n# The condition can be based on another vector\ncharacters &lt;- c(\"Yoda\", \"C-3PO\", \"Rey\", \"R2-D2\", \"Anakin\", \"Baby Yoda\")\nheights &lt;- c(66, 175, 170, 109, 183, 40.5)\n# Only characters shorter than 120 cm\ncharacters[heights &lt; 120]\n\n[1] \"Yoda\"      \"R2-D2\"     \"Baby Yoda\"\n\n\n\n\n2.3.4 Puuttuvat arvot\nMonessa tutkimusprojektissa törmätään syystä tai toisesta jossain vaiheessa puuttuviin arvoihin. Hyvä esimerkki ovat seurantatutkimukset, jossa usein seurannan lopussa on jäljellä vähemmän koehenkilöitä kuin alussa.\nPuuttuvia arvoja merkitään R:ssä symbolilla NA (not available). Puuttuvat arvot noudattavat yksinkertaista logiikkaa: mikä tahansa operaatio NA:lle antaa tulokseksi NA. Funktiot, jotka operoivat vektoreilla, kuten sum tai mean voidaan erikseen asettaa poistamaan puuttuvat arvot ennen summan, keskiarvon tms. laskemista.\n\nmissing &lt;- c(1, 2, NA, 4, NA, 6)\nfull &lt;- seq(1, 6)\n\n# Addition with NA returns NA\nmissing + full\n\n[1]  2  4 NA  8 NA 12\n\n# Sum of vector with NAs returns NA\nsum(missing)\n\n[1] NA\n\n# Removing NAs before summation\nsum(missing, na.rm = TRUE)\n\n[1] 13\n\n\nHUOM! Funktio is.na tarkistaa, onko jokin arvo puuttuva. Perinteinen yhtäsuuruuden testaaminen ei siis toimi. Funktio complete.cases muistuttaa is.na funktiota, mutta sitä voidaan käyttää myös kokonaisille aineistoille, jolloin se palauttaa totuusarvon TRUE niiden rivien kohdalla, jotka eivät sisällä lainkaan puuttuvaa tietoa yhdessäkään muuttujassa.\n\n# Just returns NA\nNA == NA\n\n[1] NA\n\n# Returns a logical value as expected\nis.na(NA)\n\n[1] TRUE\n\nis.na(1)\n\n[1] FALSE\n\n# is.na operates element-wise on a vector\nmissing &lt;- c(1, 2, NA, 4, NA, 6)\nis.na(missing)\n\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n# complete.cases gives the data elements which do not have missing data. \n# It can be used with data frames also.\ncomplete.cases(missing)\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Muuttujat ja vektorit</span>"
    ]
  },
  {
    "objectID": "02-variables.html#extra",
    "href": "02-variables.html#extra",
    "title": "2  Muuttujat ja vektorit",
    "section": "2.4 Extra: Alkeistietotyypit ja erikoisarvot",
    "text": "2.4 Extra: Alkeistietotyypit ja erikoisarvot\nTässä lisätieto-osiossa käsitellään asioita, joita et välttämättä tarvitse kurssista suoriutuaksesi. Mikäli käytät R:ää enemmän, niin vastaan tulee enemmin tai myöhemmin ongelmia, joissa tarvitsee näitä taitoja. Voit palata näihin myöhemmin koska tahansa, kun haluat syventää ymmärrystäsi R:stä.\nR on rakennettu sisäisesti siten, että vektorin kukin elementti on jotain alkeistietotyyppiä. R:ssä on valmiina kuusi alkeistietotyyppiä:\n\nlooginen (logical)\nkokonaisluku (integer)\nnumeerinen (eli reaaliluku, numeric)\nkompleksiluku (complex)\nmerkkijono (character)\nbitti (raw)\n\nNäistä tarpeellisimpia ovat numeerinen, looginen, ja merkkijono. Kompleksilukua tarvitsee vain joissain erityistapauksissa ja kokonaisluvut ovat nykyään lähes aina tallennettu numeerisina. Bittejä, eli raw-tyypin vektoreita käytetään harvoin.\n\n# Integers are usually stored as reals\nx &lt;- c(1, 2, 3)\nclass(x)\n\n[1] \"numeric\"\n\n# You can create integers by adding capital L behind the number\nx_int &lt;- c(1L, 2L, 3L)\nclass(x_int)\n\n[1] \"integer\"\n\n# Character strings (or just strings)\nx_char &lt;- c(\"I\", \"have\", \"a\", \"cat.\")\nclass(x_char)\n\n[1] \"character\"\n\n# Complex numbers\nx_comp &lt;- c(0i, 2 + 1i, 1 - 3i)\nclass(x_comp)\n\n[1] \"complex\"\n\n# Logical vector\nx_logi &lt;- c(TRUE, FALSE)\nclass(x_logi)\n\n[1] \"logical\"\n\n# Raw vector\nx_raw &lt;- as.raw(c(0, 1, 2))\nclass(x_raw)\n\n[1] \"raw\"\n\n\nJoskus vektorin tiedot ovat väärässä muodossa, esim. merkkijonoina, mutta niitä haluttaisiin käsitellä numeroarvoina. Näihin operaatioihin on omat funktionsa. Tällöin voi kuitenkin tulla ongelmia, jos muutettava vektori ei ole helposti muutettavissa haluttuun muotoon.\n\n# Chacter string to numeric\nclass(as.numeric(x_char))\n\nWarning: NAs introduced by coercion\n\n\n[1] \"numeric\"\n\n# If character contains only values it is easy\nx_char2 &lt;- c(\"0\", \"5\", \"6.5\")\nas.numeric(x_char2)\n\n[1] 0.0 5.0 6.5\n\n# Integer to numeric\nx_int_to_num &lt;- as.numeric(x_int)\nx_int_to_num\n\n[1] 1 2 3\n\nclass(x_int_to_num)\n\n[1] \"numeric\"\n\n# Numeric to integer\nx_num_to_int &lt;- as.integer(x)\nx_num_to_int\n\n[1] 1 2 3\n\nclass(x_num_to_int)\n\n[1] \"integer\"\n\n\nVielä pari lisähuomiota puuttuvista arvoista (näitä ei tarvita usein) koskien niiden tietotyyppejä. Puuttuvalla arvolla on myös alkeistietotyyppi. Mikäli NA-arvon tietotyyppi tulee määritellä, niin sen voi tehdä seuraavasti. Jos luodaan muuttuja tai vektori, jossa on vain yksi arvo, joka on NA, niin se oletusarvoisesti looginen.\n\n# Specify a numeric NA value\nNA_real_\n\n[1] NA\n\n# Specify a complex number NA value\nNA_complex_\n\n[1] NA\n\n# Specify a integer number NA value\nNA_integer_\n\n[1] NA\n\n# Specify a character NA value\nNA_character_\n\n[1] NA\n\n# NA gives a logical type when evaluated alone\nclass(NA)\n\n[1] \"logical\"\n\n# NA_real_ is numeric\nclass(NA_real_)\n\n[1] \"numeric\"\n\n\n\n2.4.1 Ääretön ja miinus ääretön\nR:ssä on myös ääretön ja miinus ääretön. Ne on toteutettu samaan tapaan kuin puuttuva arvo, mutta niiden tarkasteluun on omat funktionsa. Ääretön ja miinus ääretön arvot syntyvät esimerkiksi silloin, kun nollasta poikkeavia lukuja jaetaan nollalla.\n\n# You can type in infinity or minus infinity if needed\nx &lt;- c(1, 2, Inf, 5, -Inf)\n# Use is.finite to determine if numbers are finite or not\nis.finite(x)\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n\n# Division by zero makes Inf or -Inf (unless 0/0)\nx_div_zero &lt;- c(1, 2, -3) / c(3, 0, 0)\nx_div_zero\n\n[1] 0.3333333       Inf      -Inf\n\nis.finite(x_div_zero)\n\n[1]  TRUE FALSE FALSE\n\n\n\n\n2.4.2 Ei-numero\nMikäli R:ssä sattuu tekemään jonkin matemaattisen toimenpiteen, joka ei ole sallittu, esimerkiksi nollan jaon nollalla tai luvun \\(-1\\) logaritmin, niin tämä tuottaa R:ssä tietotyypin, joka on NaN (lyhenne sanoista Not a Number). Mikäli NaN-arvoa tutkii funktiolla is.finite tai is.na, niin huomaa että NaN ei ole äärellinen ja NaN tulkitaan NA:ksi.\n\nx_div_zero_by_zero &lt;- 0/0\n\n# Tests for NaN\nis.nan(x_div_zero_by_zero)\n\n[1] TRUE\n\n# Tests if it is finite\nis.finite(x_div_zero_by_zero)\n\n[1] FALSE\n\n# Tests if it is NA (missing)\nis.na(x_div_zero_by_zero)\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Muuttujat ja vektorit</span>"
    ]
  },
  {
    "objectID": "03-data_types.html",
    "href": "03-data_types.html",
    "title": "3  Tietotyypit",
    "section": "",
    "text": "3.1 Datakehikko (data.frame)\nDatakehikko on erittäin yleinen tietorakenne tiedon tallentamiseen R:ssä. Datakehikko on kaksiulotteinen tietorakenne, eli sillä on rivejä ja sarakkeita. Datakehikon sarakkeet muodostuvat vektoreista. Sarakevektorit voivat olla eri luokan vektoreita, mutta datakehikko asettaa lisärajoitteen: vektoreiden on oltava yhtä pitkiä. Yhden rivin sarakkeilla olevien arvojen ajatellaan koskevan yhtä havaintoa. Sarakkeet voivat sisältää myös puuttuvaa tietoa (eli NA arvoja).\nLuodaan datakehikko, jossa on kaksi muuttujaa, height ja weight, ja sijoitetaan niihin kahdeksan mittauksen tiedot. Huomionarvoista on se, että komennon data.frame sulkujen sisällä on käytettävä yhtäsuuruusmerkkiä (=) eikä sijoitusoperaattoria (&lt;-). Tämä johtuu siitä, että teknisesti ottaen data.frame on funktio (funktioista lisää myöhemmin).\nstudy_data &lt;- data.frame(\n  ID = 1:8,\n  height = c(189.8, 184.0, 173.8, 175.9, 169.0, 183.7, 181.8, 16.9),\n  gender = c(\"male\", \"female\", \"male\", \"male\", \"female\", \"male\", \"male\", \"female\")\n)\nstudy_data\n\n  ID height gender\n1  1  189.8   male\n2  2  184.0 female\n3  3  173.8   male\n4  4  175.9   male\n5  5  169.0 female\n6  6  183.7   male\n7  7  181.8   male\n8  8   16.9 female\nHuomaa, että jos sarakkeita ei itse nimeä, niin data.frame nimeää ne automaattisesti, mutta näin luodut nimet eivät välttämättä ole ollenkaan kuvaavia.\nno_names_data &lt;- data.frame(\n  1:8,\n  c(189.8, 184.0, 173.8, 175.9, 169.0, 183.7, 181.8, 16.9),\n  c(\"male\", \"female\", \"male\", \"male\", \"female\", \"male\", \"male\", \"female\")\n)\nno_names_data\n\n  X1.8 c.189.8..184..173.8..175.9..169..183.7..181.8..16.9.\n1    1                                                189.8\n2    2                                                184.0\n3    3                                                173.8\n4    4                                                175.9\n5    5                                                169.0\n6    6                                                183.7\n7    7                                                181.8\n8    8                                                 16.9\n  c..male....female....male....male....female....male....male...\n1                                                           male\n2                                                         female\n3                                                           male\n4                                                           male\n5                                                         female\n6                                                           male\n7                                                           male\n8                                                         female\nDatakehikkojen käsittelystä kerrotaan tarkemmin luvussa Datan muokkaaminen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tietotyypit</span>"
    ]
  },
  {
    "objectID": "03-data_types.html#sec-matrix",
    "href": "03-data_types.html#sec-matrix",
    "title": "3  Tietotyypit",
    "section": "3.2 Matriisi",
    "text": "3.2 Matriisi\n\n3.2.1 Matriisin luominen\nMatriisin luominen on yksinkertaista ja se tapahtuu funktiolla matrix.\n\nmatrix(1:9, nrow = 3, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nFunktiolle annetaan siis matriisiin tallennettavat luvut vektorina, sekä matriisin rivien ja sarakkeiden määrä (argumentit ncol ja nrow). Arvot sijoitetaan matriisiin sarakkeittain. Matriisi voi koostua myös kokonaan tietystä arvosta:\n\nmatrix(0, nrow = 2, ncol = 5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n\n\nJos matriisin tallennettavat luvut annetaan vektorina, niin tällöin riittää antaa vain joko rivien tai sarakkein lukumäärä, ja R osaa päätellä puuttuvan dimension annetun vektorin perusteella.\n\nmatrix(1:9, nrow = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nUseimmiten matriisien data luetaan R:ään jostain tiedostosta, joka on tuotettu Excelillä tai jollain muulla ohjelmalla (tutkimustulosten kirjaus suoraan R:ään on raskasta). Matriisien luonti käsin on kuitenkin hyvä osata, sillä pienillä matriiseilla on kätevää testata omaa koodia ja tehdä matriisilaskutoimituksia. Myös yllä olevan kaltaisia, esim. nollalla täytettyjä matriiseja on joskus kätevää käyttää “alustana”, kun lasketaan omasta datasta tuloksia rivi tai sarake kerrallaan. Tämä johtuu siitä, että olemassa olevan matriisin rivin arvojen muuttaminen on nopeampi operaatio kuin rivin lisääminen matriisiin.\n\n\n3.2.2 Matriisin koko\nJoskus voi törmätä matriiseihin, joiden kokoa ei tiedetä, tai ei haluta olettaa. Tällöin tarvitaan funktioita, jotka kertovat matriisin koosta. Esimerkiksi, kun luetaan dataa R:ään tiedostoista, on hyvä tarkistaa, että kaikki rivit ja sarakkeet ovat mukana. Funktiot nrow ja ncol palauttavat rivien ja sarakkeiden määrän, dim palauttaa matriisin rivien ja sarakkeiden määrän vektorina, jossa rivien määrä on ensimmäinen alkio.\n\nX &lt;- matrix(1:12, ncol = 4)\n# Number of rows\nnrow(X)\n\n[1] 3\n\n# Number of columns\nncol(X)\n\n[1] 4\n\n# Dimensions\ndim(X)\n\n[1] 3 4\n\n\n\n\n3.2.3 Matriisin indeksointi\nMatriisin indeksointi on hyvin samantapainen operaatio kuin vektorin indeksointi, eli matriisin perään laitetaan hakasulkeet ja niihin määritellään halutut indeksit. Matriisin indeksoinnissa pitää kuitenkin antaa erikseen indeksit riveille ja sarakkeille, pilkulla erotettuna. Jos hakasulkeisiin antaa vain yhden luvun ilman pilkkua, niin R käsittelee matriisia vektorina, jolloin indeksointi tapahtuu kuten vektoreiden tapauksessa.\n\n# Only nrow is enough, since the number of columns must be 3\nX &lt;- matrix(1:9, nrow = 3)\nX\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Element on second row, third column\nX[2, 3]\n\n[1] 8\n\n# The complete first row\nX[1, ]\n\n[1] 1 4 7\n\n# The second and third values of the second column\nX[2:3, 3]\n\n[1] 8 9\n\n# Get rows where the values of the first column are &gt; 1\nX[X[, 1] &gt; 1, ]\n\n     [,1] [,2] [,3]\n[1,]    2    5    8\n[2,]    3    6    9\n\n\nHUOM: jos matriisia indeksoidessa tuloksessa sarakkeiden tai rivien määrä on tasan yksi, kuten yllä olevissa esimerkeissä viimeistä lukuun ottamatta, tuloksena on vektori, ei matriisi. Jos haluaa tuloksen olevan matriisi, tulee hakasulkeisiin lisätä argumentti drop = FALSE\n\n# The complete first row\nX[1, , drop = FALSE]\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n\n# The second and third values of the second column\nX[2:3, 3, drop = FALSE]\n\n     [,1]\n[1,]    8\n[2,]    9\n\n\nMatriiseja voi myös muokata sijoittamalla haluttuihin paikkoihin uusia arvoja:\n\n# Copy of X\nX_new &lt;- X\n# Replace first row with new values\nX_new[1, ] &lt;- c(10, 13, 15)\nX_new\n\n     [,1] [,2] [,3]\n[1,]   10   13   15\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Replacement can also be a single value, and will be recycled\nX_new[2:3, 1] &lt;- 0\nX_new\n\n     [,1] [,2] [,3]\n[1,]   10   13   15\n[2,]    0    5    8\n[3,]    0    6    9\n\n\nMatriisista voi myös poimia tietyt rivit tai sarakkeet jättämällä tiettyjä rivejä tai sarakkeita pois. Tämä tapahtuu antamalla indeksi miinusmerkkisenä:\n\n# Without first row\nX[-1, ]\n\n     [,1] [,2] [,3]\n[1,]    2    5    8\n[2,]    3    6    9\n\n# Without second column\nX[, -2]\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n\n\nHuomaa kuitenkin, että positiivisia ja negatiivisia indeksejä ei voi käyttää samanaikaisesti tietyssä dimensiossa:\n\n# Trying to mix positive and negative indices\nX[c(-1, 1), ]\n\nError in X[c(-1, 1), ]: only 0's may be mixed with negative subscripts\n\n\n\n3.2.3.1 Indeksimatriisi (index matrix)\nJos halutaan poimia useampi yksittäinen arvo matriisista, tulee käyttää indeksimatriisia (index matrix).\nEsimerkiksi, jos haluttaisiin poimia äskeisestä matriisista x arvot indekseissä [1, 2], [1, 3] ja [2, 2], niin seuraava koodi ei toimi:\n\nX[c(1, 1, 2), c(2, 3, 2)]\n\n     [,1] [,2] [,3]\n[1,]    4    7    4\n[2,]    4    7    4\n[3,]    5    8    5\n\n\nvaan tulee käyttää indeksimatriisia, jonka jokainen rivi antaa yhden halutun alkion rivi- ja sarakeindeksin tässä järjestyksessä. Indeksimatriiseja tehdessä kannattaa asettaa argumentti byrow = TRUE, jolloin alkiot laitetaan matriisiin rivi kerrallaan, ei sarake kerrallaan kuten oletusarvoisesti tehtäisiin.\n\ni &lt;- matrix(c(1, 2, 1, 3, 2, 2), nrow = 3, byrow = TRUE)\ni\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    3\n[3,]    2    2\n\nX[i]\n\n[1] 4 7 5\n\n\n\n\n\n3.2.4 Matriisien rakentaminen vektoreista\nMatriisi koostuu usein useammasta muuttujasta ja havainnoista. Yleensä jokainen rivi vastaa yhtä havaintoa, ja sarake muuttujaa. Tämän takia on hyvä tietää, miten yksittäisistä vektoreista saa koottua matriiseja. Alla olevassa esimerkissä on koottu yhteen matriisiin Star Wars -hahmojen pituuksia ja painoja. Tämä tapahtuu cbind funktiolla (column bind), joka nimensä mukaisesti yhdistää vektorit matriisin sarakkeiksi. cbind voi yhdistää myös valmiita matriiseja yhteen, niin että matriisit ovat “vierekkäin” eli yhdistetyssä matriisissa on kummankin matriisin sarakkeet (rivien määrän tulee olla sama). Vastaavasti rbind (row bind) yhdistää matriiseja “allekkain” (sarakkeiden määrän tulee olla sama).\n\nheights &lt;- c(172, 167, 96, 202, 150, 178)\nmasses &lt;- c(77, 75, 32, 136, 49, 120)\n\nstarwars &lt;- cbind(heights, masses)\nstarwars\n\n     heights masses\n[1,]     172     77\n[2,]     167     75\n[3,]      96     32\n[4,]     202    136\n[5,]     150     49\n[6,]     178    120\n\n\n\n\n3.2.5 Rivien ja sarakkeiden nimeäminen\nMatriisien rivit ja sarakkeet voi nimetä, ja usein tässä onkin järkeä. Yllä olevassa esimerkissä starwars-matriisin sarakkeet on nimetty alkuperäisten vektorien mukaan. Alla olevassa esimerkissä on lisää tapoja nimetä rivejä ja sarakkeita\n\n# Set column names by naming arguments while building matrix from vectors\ncbind(Height = heights, Mass = masses)\n\n     Height Mass\n[1,]    172   77\n[2,]    167   75\n[3,]     96   32\n[4,]    202  136\n[5,]    150   49\n[6,]    178  120\n\n# Set column and row names explicitly\ncolnames(starwars) &lt;- c(\"Height\", \"Mass\")\nrownames(starwars) &lt;- c(\n  \"Luke Skywalker\", \"C-3PO\", \"R2-D2\", \"Darth Vader\", \"Leia Organa\", \"Owen Lars\"\n)\nstarwars\n\n               Height Mass\nLuke Skywalker    172   77\nC-3PO             167   75\nR2-D2              96   32\nDarth Vader       202  136\nLeia Organa       150   49\nOwen Lars         178  120\n\n\nNimettyjä matriiseja voi indeksoida myös nimien perusteella:\n\nstarwars[c(\"Luke Skywalker\", \"R2-D2\"), ]\n\n               Height Mass\nLuke Skywalker    172   77\nR2-D2              96   32\n\n\nMatriisiin voi myös lisätä uusia sarakkeita cbind funktiolla. Alla lisätään matriisiin starwars uusi sarake, jossa on hahmojen BMI:\n\n# Create a vector for BMI and add to matrix with cbind\nbmi &lt;- starwars[, \"Mass\"] / (starwars[, \"Height\"] / 100)^2\ncbind(starwars, \"BMI\" = bmi)\n\n               Height Mass      BMI\nLuke Skywalker    172   77 26.02758\nC-3PO             167   75 26.89232\nR2-D2              96   32 34.72222\nDarth Vader       202  136 33.33007\nLeia Organa       150   49 21.77778\nOwen Lars         178  120 37.87401\n\n\n\n\n3.2.6 Matriiseilla laskeminen\nMatriiseilla laskeminen on hyvin samankaltaista kuin vektoreilla laskeminen. Matriisin ja yksittäisen luvun välisessä operaatiossa matriisin alkiot käsitellään yksitellen. Samoin samankokoiset matriisit voi esim. lisätä yhteen, jolloin lisäys tapahtuu alkio kerrallaan.\n\nX &lt;- matrix(1:9, nrow = 3)\nY &lt;- matrix(3:11, nrow = 3, ncol = 3)\n# Element-wise multiplication\nX * 2\n\n     [,1] [,2] [,3]\n[1,]    2    8   14\n[2,]    4   10   16\n[3,]    6   12   18\n\n# Element-wise sum\nX + Y\n\n     [,1] [,2] [,3]\n[1,]    4   10   16\n[2,]    6   12   18\n[3,]    8   14   20\n\n\nMatriiseille on lisäksi määritelty paljon matriisien omia laskutoimituksia, joita ei käsitellä tarkemmin tässä materiaalissa. Matriisilaskentaa opiskelleille huomio: R:ssä oletuksena kertolasku tehdään alkioittain, matriisitulo tapahtuu operaattorilla %*% ja matriisin transpoosin voi määrittää funktiolla t.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tietotyypit</span>"
    ]
  },
  {
    "objectID": "03-data_types.html#tietotyyppien-tarkastelu",
    "href": "03-data_types.html#tietotyyppien-tarkastelu",
    "title": "3  Tietotyypit",
    "section": "3.3 Tietotyyppien tarkastelu",
    "text": "3.3 Tietotyyppien tarkastelu\nKaikkia objekteja voi tulostaa Console-ikkunassa kutsumalla objektin nimen. Joskus tarvitaan kuitenkin apufunktioita.\n\n3.3.1 View()\nMikäli käytät RStudiota, niin tarkempaa tarkastelua varten kannattaa kuitenkin käyttää View-funktiota. View avaa ikkunan, jossa voi selata data framen tai matriisin rivejä ja sarakkeita, sekä järjestää arvoja halutun sarakkeen mukaan (tämä järjestys säilyy vain View-näkymässä, itse muuttujan rakenne ei muutu). Mikäli aineistossasi on satoja tuhansia tai miljoonia rivejä, niin View saattaa olla liian hidas.\n\n\n3.3.2 str()\nPerineinen tapa tarkastella objekteja R:ssä on funktio str, joka toimii kaikissa R-ympäristöissä. Funktio str tulostaa tiivistetyssä muodossa kaiken, mitä sille annettu objekti sisältää. Esimerkiksi datakehikon tapauksessa sen avulla saadaan sekä muuttujien nimet, niitä vastaavien vektoreiden tyypit että ruudulle mahtuvan osan vektoreiden alkioista.\n\n# Examine the structure of data frame\nstr(study_data)\n\n'data.frame':   8 obs. of  3 variables:\n $ ID    : int  1 2 3 4 5 6 7 8\n $ height: num  190 184 174 176 169 ...\n $ gender: chr  \"male\" \"female\" \"male\" \"male\" ...\n\n\n\n\n3.3.3 head()\nJos aineistossa on todella paljon rivejä, on sen tulostaminen Console-ikkunaan ikävää. Ladataan esimerkiksi iris-data, jossa on 150 havaintoa. Tulostettaessa rivejä on niin monta, että muuttujien nimet eivät näy, mikä on epämiellyttävää. Parempi tapa saada käsitys aineistosta on kutsua sitä head-funktion avulla.\n\n# Load data for this example\ndata(iris)\n\n# Try to print iris-data directly\niris\n\n\n\n# Print 6 first rows of iris data\nhead(iris)\n\n\n\n# You can also define the number of rows to print\nhead(iris, 2)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tietotyypit</span>"
    ]
  },
  {
    "objectID": "03-data_types.html#extra-taulukko-ja-lista",
    "href": "03-data_types.html#extra-taulukko-ja-lista",
    "title": "3  Tietotyypit",
    "section": "3.4 Extra: Taulukko ja lista",
    "text": "3.4 Extra: Taulukko ja lista\nTaulukoita ja listoja ei perus data-analyysiä toteutettaessa yleensä tarvita. Lue kuitenkin seuraava, jotta saat yleiskäsityksen mihin niitä tarvitaan. Voit myös palata perehtymään taulukoihin ja listoihin myöhemmin koska tahansa.\n\n3.4.1 Taulukko\nKuten alussa todettiin, taulukot (array) ovat hyvin harvinaisia, joten niihin ei kannata tällä kurssilla keskittyä. Niitä kuitenkin tarvitaan joidenkin tehtävien tekemiseen, joten tässä on hyvin lyhyt oppimäärä taulukoista.\nTaulukot ovat matriisien kaltaisia, mutta taulukossa voi olla yli kaksi ulottuvuutta. Oikeastaan matriisit ovat kaksiulotteisia taulukoita. Alla on esimerkki 3-ulotteisesta taulukosta, jota voi ajatella “peräkkäin” olevina matriiseina. Alla on kuva 1-ulotteisesta taulukosta eli vektorista, 2-ulotteisesta taulukosta eli matriisista ja 3-ulotteisesta taulukosta.\n\nTaulukkoja luodaan matriisien tapaan funktiolla array. Toisin kuin matriisien tapauksessa, array-funktiolle pitää luetella sen kaikki ulottuvuudet vektorina. Alla oleva esimerkki luo 3-ulotteisen taulukon, jonka voi ajatella koostuvan kolmesta \\(4 \\times 2\\) matriisista.\n\nmy_array &lt;- array(1:24, dim = c(4, 2, 3))\nmy_array\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n, , 2\n\n     [,1] [,2]\n[1,]    9   13\n[2,]   10   14\n[3,]   11   15\n[4,]   12   16\n\n, , 3\n\n     [,1] [,2]\n[1,]   17   21\n[2,]   18   22\n[3,]   19   23\n[4,]   20   24\n\n\n\nTaulukoita indeksoidaan aivan kuten matriiseja, mutta jokaiselle ulottuvuudelle on annettava oma indeksi:\n\n# The first 2 rows of each \"layer\"\nmy_array[1:2, , ]\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    9   13\n[2,]   10   14\n\n, , 3\n\n     [,1] [,2]\n[1,]   17   21\n[2,]   18   22\n\n# Second column from last two layers\nmy_array[, 2, 2:3]\n\n     [,1] [,2]\n[1,]   13   21\n[2,]   14   22\n[3,]   15   23\n[4,]   16   24\n\n\n\n\n3.4.2 Lista\nListat ovat tärkeitä erityisesti silloin, kun aletaan toteuttamaan uusia toimintoja R-kieleen omien funktioiden avulla. Niin kauan kun valmiit R-funktiot riittävät, ei listoilla ole juuri käyttöä.\nLista (list) on vektorinkaltainen tietorakenne, jossa on järjestyksessä alkioita, jotka on mahdollisesti nimetty. Tärkeä ero vektoriin verrattuna on, että listan alkiot voivat olla erityyppisiä. Listoja luodaan list-funktiolla:\n\nexample_list &lt;- list(\n  c(1, 2, 3),\n  matrix(0, nrow = 3, ncol = 4),\n  \"list can include anything\"\n)\nexample_list\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0    0    0    0\n\n[[3]]\n[1] \"list can include anything\"\n\nsubject_ids &lt;- c(\"ANKL\", \"PEPA\", \"DIPR\")\nmeasurements &lt;- matrix(\n  c(\n    1, 2.5, 3,\n    3.5, 5, 3,\n    2.3, 3, 1.6\n  ),\n  nrow = 3\n)\ncolnames(measurements) &lt;- c(\"CRP\", \"HDL\", \"LDL\")\nrownames(measurements) &lt;- subject_ids\n# List names can be given with or without quotes\nstudy &lt;- list(\n  Subject_ID = subject_ids,\n  \"Measurements\" = measurements,\n  Study_name = \"Blood tests\"\n)\nstudy\n\n$Subject_ID\n[1] \"ANKL\" \"PEPA\" \"DIPR\"\n\n$Measurements\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\n$Study_name\n[1] \"Blood tests\"\n\n\nListoja ja niiden kaltaisia olioita käytetään R:ssä paljon. Listoihin on kätevä tallentaa erityyppistä tietoa, joka kuitenkin halutaan säilyttää yhtenä kokonaisuutena. Esimerkiksi yksinkertaisetkin tilastolliset mallit tuottavat paljon erilaista tietoa, joka tallennetaan listaan (tarkemmin listan kaltaiseen olioon, tästä lisää myöhemmin).\n\n3.4.2.1 Listojen alkioiden käsittely\nListan alkioihin pääsee käsiksi kahdella eri tavalla: kaksoishakasulkeilla [[]] tai, jos lista on nimetty, dollarimerkillä $:\n\n# By position\nstudy[[2]]\n\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\n# By name\nstudy[[\"Subject_ID\"]]\n\n[1] \"ANKL\" \"PEPA\" \"DIPR\"\n\n# Using dollar sign\nstudy$Study_name\n\n[1] \"Blood tests\"\n\n\nListaa voi indeksoida myös yksinkertaisilla hakasulkeilla. Tällöin palautetaan aina lista, eikä yksittäistä alkiota kuten aiemmin. Palautetaan ensiksi mieleen funktio class, joka palauttaa argumenttinsa luokan (class). Vektorin luokka vaihtelee vektorin sisällön mukaan: numeric = lukuja, character = merkkijonoja, logical = loogisia arvoja, jne. Listojen luokka on luonnollisesti list. R:ssä kaikki muuttujiin tallennettavat tiedot ovat olioita (object). R-olioilla on aina luokka, joka määrittää sen ominaisuudet. Esimerkiksi print ja plot-komennot toimivat eri tavalla riippuen niiden argumentin luokasta.\nTarkastellaan alla, mikä ero yksinkertaisilla ja kaksinkertaisilla hakasulkeilla on listan indeksoinnissa:\n\n# Returns a list of length one with the matrix as the only element\nstudy[2]\n\n$Measurements\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\nclass(study[2])\n\n[1] \"list\"\n\n# Returns the actual matrix\nstudy[[2]]\n\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\nclass(study[[2]])\n\n[1] \"matrix\" \"array\" \n\n# Dollar sign also returns the matrix\nclass(study$Measurements)\n\n[1] \"matrix\" \"array\" \n\n# Single brackets works as subscripting just like with vectors\nstudy[2:3]\n\n$Measurements\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\n$Study_name\n[1] \"Blood tests\"\n\n\n\n\n3.4.2.2 Alkion lisäys listaan ja listojen yhdistäminen\nYksittäisen alkion voi lisätä listaan sijoittamalla listan johonkin indeksiin tai nimeen uusi arvo (indeksin pitää olla yhtä suurempi kuin listan pituus). HUOM! Listan alkio voi myös itse olla lista (sisäkkäinen lista = nested list).\n\n# Add a character matrix as the fourth element of study\nstudy[[4]] &lt;- matrix(\n  c(\n    \"CPR\", \"HDL\", \"LDL\",\n    \"C-reactive protein\", \"High-density lipoprotein\", \"Low-density lipoprotein\"\n  ),\n  ncol = 2\n)\n# An element of a list can also be a list\nstudy[[\"professional\"]] &lt;- list(\n  name = c(\"John H. Watson\"),\n  position = \"Medical doctor\",\n  age = 45\n)\nstudy\n\n$Subject_ID\n[1] \"ANKL\" \"PEPA\" \"DIPR\"\n\n$Measurements\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\n$Study_name\n[1] \"Blood tests\"\n\n[[4]]\n     [,1]  [,2]                      \n[1,] \"CPR\" \"C-reactive protein\"      \n[2,] \"HDL\" \"High-density lipoprotein\"\n[3,] \"LDL\" \"Low-density lipoprotein\" \n\n$professional\n$professional$name\n[1] \"John H. Watson\"\n\n$professional$position\n[1] \"Medical doctor\"\n\n$professional$age\n[1] 45\n\n# Note that the fourth element has no name\nnames(study)\n\n[1] \"Subject_ID\"   \"Measurements\" \"Study_name\"   \"\"             \"professional\"\n\n\nListoja voi yhdistää vektorien tapaan c-funktiolla:\n\n# Concatenate two vectors\nvector1 &lt;- c(3, 6, 5)\nvector2 &lt;- c(1, 2, 3)\nc(vector1, vector2)\n\n[1] 3 6 5 1 2 3\n\nlist1 &lt;- list(vector = vector1, name = \"list1\")\nlist2 &lt;- study[1:2]\n# Concatenate three lists, names stay the same\nc(list1, list2, list(first_element = \"A\", second = \"B\"))\n\n$vector\n[1] 3 6 5\n\n$name\n[1] \"list1\"\n\n$Subject_ID\n[1] \"ANKL\" \"PEPA\" \"DIPR\"\n\n$Measurements\n     CRP HDL LDL\nANKL 1.0 3.5 2.3\nPEPA 2.5 5.0 3.0\nDIPR 3.0 3.0 1.6\n\n$first_element\n[1] \"A\"\n\n$second\n[1] \"B\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Tietotyypit</span>"
    ]
  },
  {
    "objectID": "04-reading_data.html",
    "href": "04-reading_data.html",
    "title": "4  Datan lukeminen",
    "section": "",
    "text": "4.1 Hakemistopolut ja tiedostopäätteet",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datan lukeminen</span>"
    ]
  },
  {
    "objectID": "04-reading_data.html#hakemistopolut-ja-tiedostopäätteet",
    "href": "04-reading_data.html#hakemistopolut-ja-tiedostopäätteet",
    "title": "4  Datan lukeminen",
    "section": "",
    "text": "4.1.1 Hakemistopolut\nJotta aineiston lataus tiedostosta onnistuu, tulee käyttäjän olla tietoinen siitä, missä hakemistopolussa eli kansiossa R työskentelee lataushetkellä. R:llä on siis koko ajan jokin hakemistopolku, johon se viittaa. R:n käyttämän hakemistopolun saat selville komennolla getwd().\n\ngetwd()\n\n[1] \"C:/Users/jukop/Documents\"\nTämän esimerkin tapauksessa R käyttää siis hakemistoa C:/Users/jukop/Documents. Jos kurssilla tarvittavan datasets.zip -tiedoston aineistot olisi purettu kansioon C:/Users/jukop/Documents/datasets, niin hakemistopolkju kannattaa vaihtaa juuri tähän hakemistoon. Se tapahtuu näin:\n\nsetwd(\"C:/Users/jukop/Documents/datasets\")\n\nsetwd ei tulosta mitään, jos kansion vaihtaminen onnistuu. Komennolla getwd() voidaan uudelleen tarkastaa, että hakemisto todella vaihtui. Vinkki! Ellet tiedä mikä on tarkka hakemistopolku, johon olet purkanut tiedostot, niin se onnistuu klikkaamalla Windowsissa tiedostoselaimen osoiteriviä. Voit kopioida hakemistopolun siitä, mutta vaihda kuitenkin kenoviivat (\\) kauttaviivoiksi (/). Kenoviivoilla on R:ssä erityismerkitys merkkijonoissa, joten ne eivät kelpaa sellaisenaan. Kaksinkertainen kenoviiva (\\\\) toimisi myös.\n\n\n\n4.1.2 Tiedostopäätteet\nWindows ei oletuksena nykyisin näytä tiedostopäätteitä. Ne kannattaakin asettaa näkymään tiedostoselaimen avulla. Kyseinen asetus löytyy tiedostoselaimen View-välilehdeltä kohdasta Show/Hide valinta File extensions. Merkitse kyseinen kohta valituksi, jolloin näet tiedostopäätteet, kuten kuvassa. Nyt on helppoa käsittää, kun opettaja puhuu CSV-tiedostoista, että niiden tiedostopääte on .csv.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datan lukeminen</span>"
    ]
  },
  {
    "objectID": "04-reading_data.html#tekstitiedostot",
    "href": "04-reading_data.html#tekstitiedostot",
    "title": "4  Datan lukeminen",
    "section": "4.2 Tekstitiedostot",
    "text": "4.2 Tekstitiedostot\nTekstitiedosto tarkoittaa tässä tapauksessa tiedostoa, joka ei sisällä tekstin lisäksi mitään muuta, kuten erilaisia muotoilutietoja. Tekstitiedostojen yleisimmät tiedostopäätteet ovat .txt ja .csv (comma separated value). Esim. Excelin .xlsx-tiedostot tai Wordin .docx-tiedostot eivät ole tekstitiedostoja, koska niissä on paljon muutakin tietoa tekstin lisäksi.\n\n4.2.1 read.table\nKun dataa tallennetaan tekstitiedostoon, tiedoston ensimmäisellä rivillä ovat usein sarakkeiden nimet, ja seuraavilla riveillä mahdollisesti rivin nimi, ja sitten sarakkeiden arvot. Jokaisen kentän tulee olla erotettu samalla merkillä (field separator character). Yleisiä erotinmerkkejä ovat sarkain eli tab, välilyönti ja pilkku. Alla olevassa esimerkissä on neljältä kuvitteelliselta koehenkilöltä mitattu puna-vihervärisokeuteen liitettyjen geenien OPN1LW ja OPN1MW ilmentymistasot (lukuarvot ovat allekirjoittaneen hihasta). Tässä eri arvot on erotettu sarkaimella.\nSubject_ID  OPN1LW  OPN1MW\nANKL    11264   12365\nDIPR    10636   12725\nPEPA    5630    13248\nBRWA    8294    13060\nTämä data löytyy myös oheisesta tiedostosta gene_data.txt. Tekstitiedostot voi lukea sisään funktiolla read.table, jolla on tiedoston polun (file path) lisäksi monta muutakin argumenttia, joista tärkeimmät ovat:\n\nheader: looginen arvo (TRUE/FALSE), jolla kerrotaan funktiolle, onko ensimmäisellä rivillä sarakkeiden nimet vai ei\nsep: erotinmerkki, jolla muuttujien arvot on eroteltu\ndec: desimaalierotin eli desimaalilukujen merkki, jolla desimaalit on eroteltu. Tämä on tärkeä lähinnä suomalaisille, koska Suomessa desimaalierotin on jostain syystä pilkku, eikä piste kuten useimmissa muissa maissa.\n\nLuetaan edellisen esimerkin data R:ään datakehikoksi hakemistosta data:\n\ngene_data &lt;- read.table(\"data/gene_data.txt\", header = TRUE)\ngene_data\n\n  Subject_ID OPN1LW OPN1MW\n1       ANKL  11264  12365\n2       DIPR  10636  12725\n3       PEPA   5630  13248\n4       BRWA   8294  13060\n\n\nYllä olevassa esimerkissä ei määritelty erikseen erotinmerkkiä, jolloin erotinmerkiksi tulkitaan kaikki tyhjä tila (white space) eli välilyönnit, sarkaimet jne. Halutessaan erotinmerkin voi myös asettaa. Jos erotinmerkki on sarkain, tulee asettaa sep = \"\\t\"\n\ngene_data &lt;- read.table(\"data/gene_data.txt\", sep = \"\\t\", header = TRUE)\ngene_data\n\n  Subject_ID OPN1LW OPN1MW\n1       ANKL  11264  12365\n2       DIPR  10636  12725\n3       PEPA   5630  13248\n4       BRWA   8294  13060\n\n\nKuten yllä huomattiin, sarkain erotinmerkkinä merkataan \"\\t\", eikä lainausmerkeillä, joiden sisään laitettaisiin tyhjää tilaa sarkainnäppäimellä. Tämä on yksi esimerkki koodinvaihtomerkin (escape character) \\ käytöstä. R:ssä ja ohjelmointikielissä ylipäätään kenoviiva toimii koodinvaihtomerkkinä, eli sitä ei käsitellä kuin muita merkkejä, vaan se muuttaa seuraavan merkin toimintaa. Usein tämä tarkoittaa sitä, että kenoviivan avulla merkataan sarkainta, rivinvaihtoa (newline, \\n) ja muita erikoismerkkejä. Koodinvaihtomerkin käyttöä ei tarvitse osata tämän enempää, mutta se esitellään tässä, koska se aiheuttaa ongelmia Windowsin käyttäjille.\nWindowsin tiedostopoluissa kansioiden välissä on kenoviiva, kun taas Mac- ja Linux-järjestelmissä käytetään kauttaviivaa /. Koska R:ssä kenoviiva on koodinvaihtomerkki, niin helpoin tapa on käyttää tiedostopoluissa Macin ja Linuxien tyyliä. Jos taas halutaan lukea tiedosto R:ään käyttäen Windowsin tapaisia tiedostopolkuja, kenoviivat \\ pitää kirjoittaa kahteen kertaan eli \\\\, jotta R tulkitsee polun oikein. Tällöin ensimmäinen kenoviiva kertoo, että toinen kenoviiva on aito kenoviiva, eikä koodinvaihtomerkki.\nLuetaan seuraavaksi sisään data-hakemistossa oleva tiedosto tooth_growth.csv, joka sisältää dataa tutkimuksesta c-vitamiinin vaikutuksesta hampaiden kasvuun marsuilla. .csv-tiedostopääte tulee sanoista comma separated value, eli tiedostossa arvot ovat eroteltu pilkulla. Asetetaan siis sep-argumentiksi \",\". Tämä tiedosto sisältää myös rivien nimet ensimmäisessä sarakkeessa. Tämä voidaan kertoa read.table-funktiolle argumentilla row.names, jonka arvoksi voi asettaa sarakkeen numeron, josta rivien nimet napataan.\n\ntooth &lt;- read.table(\"data/tooth_growth.csv\", header = TRUE, sep = \",\", row.names = 1)\ntooth\n\n    len supp dose\n34  9.7   OJ  0.5\n16 17.3   VC  1.0\n55 24.8   OJ  2.0\n44 26.4   OJ  1.0\n58 27.3   OJ  2.0\n26 32.5   VC  2.0\n14 17.3   VC  1.0\n60 23.0   OJ  2.0\n15 22.5   VC  1.0\n9   5.2   VC  0.5\n\n\nTutkimuksessa marsuille annettiin C-vitamiinia eri annoksina (dose, mitattu milligrammoina), joko appelsiinimehussa (OJ) tai askorbiinihappona (VC), ja mitattiin odontoblastien (hammasluun emosolu) pituus (len).\n\n\n4.2.2 read.csv\nTiedostot, joissa arvot ovat pilkulla eroteltuina ovat niin yleisiä, että niiden lukemiseen on oma funktio: read.csv, joka on käytännössä sama funktio kuin read.table, mutta parametrien oletusarvot ovat erilaiset, niin että read.csv(file) ~ read.table(file, header = TRUE, sep = \",\")).\n\ntooth &lt;- read.csv(\"data/tooth_growth.csv\", row.names = 1)\ntooth\n\n    len supp dose\n34  9.7   OJ  0.5\n16 17.3   VC  1.0\n55 24.8   OJ  2.0\n44 26.4   OJ  1.0\n58 27.3   OJ  2.0\n26 32.5   VC  2.0\n14 17.3   VC  1.0\n60 23.0   OJ  2.0\n15 22.5   VC  1.0\n9   5.2   VC  0.5\n\n\n\n4.2.2.1 read.csv2\nHUOM: Koska Suomessa pilkkua käytetään desimaalierottimena, kenttien rajaaminen pilkulla ei toimi. Käytännössä tämä näkyy siten, että suomenkielinen Excel tallentaa .csv-tiedosto oletuksena muodossa, jossa desimaalierottimena on pilkku ja kenttien välissä puolipilkku ;. Jos siis olet tallentanut Excelistä taulukon .csv-muotoon ja sen lukeminen R:ään aiheuttaa hankaluuksia, kyse on todennäköisesti erotinmerkistä. Onneksi R:ssä on valmiina funktio read.csv2, joka osaa lukea puolipilkulliset .csv-tiedostot oikein.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datan lukeminen</span>"
    ]
  },
  {
    "objectID": "04-reading_data.html#datakehikon-tarkastelu",
    "href": "04-reading_data.html#datakehikon-tarkastelu",
    "title": "4  Datan lukeminen",
    "section": "4.3 Datakehikon tarkastelu",
    "text": "4.3 Datakehikon tarkastelu\nKun data on luettu sisään R:ään, kannattaa aina tarkistaa, että kaikki data on luettu oikein. Tässä muutama vinkki datakehikon tutkimiseen, joista osaa käsiteltiin jo datakehikko-kappaleessa:\ndim antaa datakehikon dimensiot, eli rivien ja sarakkeiden määrän.\nView avaa datakehikon erilliseen ikkunaan, jossa sitä voi tarkastella. Suositellaan vain pienemmille datakehikoille str kertoo rivien ja sarakkeiden määrät sekä kaikkien sarakkeiden luokat. Kätevä tapa tarkistaa mm. että lukuja sisältävät sarakkeet eivät ole vahingossa muuttuneet merkkijonoiksi. table on kätevä kategoristen sarakkeiden tutkimiseen. Se kertoo, kuinka monta havaintoa muuttujan arvoilla on. table voi ottaa vastaan myös kaksi kategorista muuttujaa, ja laskee jokaiselle muuttujien arvojen yhdistelmälle havaintojen lukumäärän.\nKatsotaan, mitä str kertoo juuri lukemastamme tooth-datasta.\n\nstr(tooth)\n\n'data.frame':   10 obs. of  3 variables:\n $ len : num  9.7 17.3 24.8 26.4 27.3 32.5 17.3 23 22.5 5.2\n $ supp: chr  \"OJ\" \"VC\" \"OJ\" \"OJ\" ...\n $ dose: num  0.5 1 2 1 2 2 1 2 1 0.5\n\n\nKuten näimme aiemmin, mukana on 10 havaintoa ja 3 muuttujaa. len ja dose ovat luokkaa numeric eli desimaalilukuja, ja supp on luokkaa factor. Factor-tietotyyppiä käsitellään enemmän lineaaristen mallien yhteydessä, mutta sillä merkitään usein kategorisia muuttujia.\nLasketaan seuraavaksi, kuinka monelle marsulle annettiin appelsiinimehua ja kuinka monelle askorbiinihappoa.\n\ntable(tooth$supp)\n\n\nOJ VC \n 5  5 \n\n\nKumpaakin annostelutapaa käytettiin siis viisi kertaa. Voimme myös selvittää, miten eri annokset jakautuvat annostelutavan suhteen:\n\ntable(tooth$supp, tooth$dose)\n\n    \n     0.5 1 2\n  OJ   1 1 3\n  VC   1 3 1\n\n\nAppelsiinimehuna annettiin siis 0.5 mg ja 1 mg annoksia kumpaakin 1 kappale, ja 2 mg annoksia 3 kappaletta.\n\n4.3.1 R:n sisäänrakennetut aineistot\nR:ssä on monta sisäänrakennettua aineistoa. Näitä on kätevää käyttää nopeaan testaamiseen, ja ne vilahtelevatkin usein R-oppaissa. Esimerkiksi aikaisempi odontoblastien pituuksia sisältävä aineistomme on oikeastaan pieni otos R:n sisäisestä aineistotsa ToothGrowth.\nR:n sisäiset aineistot ovat koko ajan käytettävissä, vaikka ne eivät näy RStudion ympäristössä (Environment). Voimme esimerkiksi katsoa, millainen rakenne kokonaisella ToothGroth-datalla on:\n\nstr(ToothGrowth)\n\n'data.frame':   60 obs. of  3 variables:\n $ len : num  4.2 11.5 7.3 5.8 6.4 10 11.2 11.2 5.2 7 ...\n $ supp: Factor w/ 2 levels \"OJ\",\"VC\": 2 2 2 2 2 2 2 2 2 2 ...\n $ dose: num  0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...\n\n\nR:n aineistoja voi käyttää moneen eri tarkoitukseen, kuten datan visualisoinnin tai tilastollisten toimenpiteiden testaamiseen. Listan kaikista R:n sisäisitä aineistoista saa komennolla data(). Tarkempia tietoja yksittäisistä aineistoista saa help-sivulta kuten funktioden tapauksessa, esimerkiksi ?ToothGrowth",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datan lukeminen</span>"
    ]
  },
  {
    "objectID": "04-reading_data.html#muut-tiedostot",
    "href": "04-reading_data.html#muut-tiedostot",
    "title": "4  Datan lukeminen",
    "section": "4.4 Muut tiedostot",
    "text": "4.4 Muut tiedostot\n\n4.4.1 Excel\nExcelin käyttämiä .xlsx-tiedostoja voi lukea suoraan R:ään, vaikka jossain netissä olevissa ohjeissa suositellaan niiden muuntamista ensin .csv-muotoon. Tätä varten pitää asentaa readxl-paketti, minkä voi tehdä RStudion Packages-valikoksta tai suoraan komennolla install.packages(\"readxl\"). Paketin funktiolla read_xlsx() voi lukea sisään .xlsx-tiedostoja, tai yksikkäitisä taulukon sivuja. Excel-tiedostojen kirjoittamiseen löytyy myös vastaava paketti writexl.\nVaihtoehtoinen paketti Excel-tiedostojen lukemiseen on openxlsx, jolla voi sekä lukea että kirjoittaa .xlsx-tiedostoja, mutta se on tyypillisesti hitaampi readxl ja writexl paketteihin verattuna.\n\n\n4.4.2 SPSS\nEri tutkimusryhmissä dataa säilytetään usein SPSS-tiedostoissa (.sav). SPSS-tiedostojen käsittelyyn voi käyttää haven-paketin funktioita read_sav ja write_sav. haven-paketti sisältää myös funktiot Stata- ja SAS-tiedostoille.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datan lukeminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html",
    "href": "05-data_wrangling.html",
    "title": "5  Datan muokkaaminen",
    "section": "",
    "text": "5.1 Uuden muuttujan tai rivin luonti datakehikkoon\nUusi muuttuja voidaan luoda R:ssä joko perustuen aineiston muihin muuttujiin, tai muuttujan arvot voidaan syöttää vektorina aineistoon. Mikäli uusi muuttuja syötetään lukuina R-koodiin, tulee varmistua siitä, että havaintoja on sama määrä kuin aineistossa on rivejä. Muutoin aineisto tulee syötettyä virheellisesti ja tulokset eivät pidä paikkaansa.\nUuden sarakkeen luonti tapahtuu samalla tavalla kuin jo olemassa olevan sarakkeen muokkaaminen eli dollarisymbolilla, jossa dollarin jälkeen annetaan ensin uuden sarakkeen nimi ja tähän sijoitetaan halutut uuden muuttujan arvot.\nstudy_data &lt;- read.table(\"data/study_data.txt\")\n\n# evaluate the number of rows and columns\ndim(study_data)\n\n[1] 8 3\n\n# there are 8 rows\n\n# initiate a new variable called weight (imput data) with correct number of rows\nstudy_data$weight &lt;- c(78.2, 65.8, 49.2, 71.2, 58.3, 54.1, 74.2, 62.8)\n\n# calculate a new variable based on existing variables\nstudy_data$height_m &lt;- study_data$height / 100 # height as metres\nstudy_data$BMI &lt;- study_data$weight / (study_data$height_m^2)\nstudy_data\n\n  ID height gender weight height_m        BMI\n1  1  189.8   male   78.2    1.898   21.70773\n2  2  184.0 female   65.8    1.840   19.43526\n3  3  173.8   male   49.2    1.738   16.28792\n4  4  175.9   male   71.2    1.759   23.01168\n5  5  169.0 female   58.3    1.690   20.41245\n6  6  183.7   male   54.1    1.837   16.03168\n7  7  181.8   male   74.2    1.818   22.44999\n8  8   16.9 female   62.8    0.169 2198.80256",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html#datakehikon-käsittely",
    "href": "05-data_wrangling.html#datakehikon-käsittely",
    "title": "5  Datan muokkaaminen",
    "section": "5.2 Datakehikon käsittely",
    "text": "5.2 Datakehikon käsittely\nDatakehikosta voidaan poimia sarakkeita joko niiden nimien tai niitä vastaavien indeksien perusteella, kuten matriisin tapauksessa. Yksittäisiä sarakkeita voidaan poimia ja muokata myös dollarisymbolin $ kautta.\n\n# Subscripting with variable names\nstudy_data[, c(\"height\", \"gender\")]\n\n  height gender\n1  189.8   male\n2  184.0 female\n3  173.8   male\n4  175.9   male\n5  169.0 female\n6  183.7   male\n7  181.8   male\n8   16.9 female\n\n# Subscripting with brackets - as matrix (but I do not recommend this style!)\nstudy_data[, 1:2]\n\n  ID height\n1  1  189.8\n2  2  184.0\n3  3  173.8\n4  4  175.9\n5  5  169.0\n6  6  183.7\n7  7  181.8\n8  8   16.9\n\n# Rownames and colnames\ncolnames(study_data)\n\n[1] \"ID\"       \"height\"   \"gender\"   \"weight\"   \"height_m\" \"BMI\"     \n\nnames(study_data)\n\n[1] \"ID\"       \"height\"   \"gender\"   \"weight\"   \"height_m\" \"BMI\"     \n\n# Individual columns can be accessed and added with dollar sign\n# Let's say that we find out that the ID number 8 was typed in incorrectly. We can fix the entire height variables as follows\nstudy_data$height &lt;- c(189.8, 184.0, 173.8, 175.9, 169.0, 183.7, NA, 160.9)\nstudy_data\n\n  ID height gender weight height_m        BMI\n1  1  189.8   male   78.2    1.898   21.70773\n2  2  184.0 female   65.8    1.840   19.43526\n3  3  173.8   male   49.2    1.738   16.28792\n4  4  175.9   male   71.2    1.759   23.01168\n5  5  169.0 female   58.3    1.690   20.41245\n6  6  183.7   male   54.1    1.837   16.03168\n7  7     NA   male   74.2    1.818   22.44999\n8  8  160.9 female   62.8    0.169 2198.80256\n\n# It would have been possible to change value of only one cell e.g. like this\nstudy_data$height[8] &lt;- 161.9\nstudy_data\n\n  ID height gender weight height_m        BMI\n1  1  189.8   male   78.2    1.898   21.70773\n2  2  184.0 female   65.8    1.840   19.43526\n3  3  173.8   male   49.2    1.738   16.28792\n4  4  175.9   male   71.2    1.759   23.01168\n5  5  169.0 female   58.3    1.690   20.41245\n6  6  183.7   male   54.1    1.837   16.03168\n7  7     NA   male   74.2    1.818   22.44999\n8  8  161.9 female   62.8    0.169 2198.80256\n\n\nUuden rivin lisäys datakehikkoon on hieman monimutkaisempaa kuin uuden rivin lisääminen matriisiin, sillä ensin pitää tehdä uusi datakehikko, jolla on samat sarakkeet kuin alkuperäisellä (samassa järjestyksessä), ja vasta sitten liittää se komennolla rbind. Käyttäjän tulee myös huolehtia siitä, että sarakkeet ovat samaa tyyppiä kuin alkuperäisessä datakehikossa.\n\nnew_row &lt;- data.frame(\n  ID = 11, \n  height = 182, \n  gender = \"male\", \n  weight = 81.2, \n  height_m = 1.82,\n  BMI = 81.2 / 1.82^2\n)\nrbind(study_data, new_row)\n\n   ID height gender weight height_m        BMI\n1   1  189.8   male   78.2    1.898   21.70773\n2   2  184.0 female   65.8    1.840   19.43526\n3   3  173.8   male   49.2    1.738   16.28792\n4   4  175.9   male   71.2    1.759   23.01168\n5   5  169.0 female   58.3    1.690   20.41245\n6   6  183.7   male   54.1    1.837   16.03168\n7   7     NA   male   74.2    1.818   22.44999\n8   8  161.9 female   62.8    0.169 2198.80256\n11 11  182.0   male   81.2    1.820   24.51395",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html#osajoukon-valinta",
    "href": "05-data_wrangling.html#osajoukon-valinta",
    "title": "5  Datan muokkaaminen",
    "section": "5.3 Osajoukon valinta",
    "text": "5.3 Osajoukon valinta\nAineistosta voi poimia osajoukon hakasulkujen avulla indeksoimalla. Osajoukon poimintaan tarvitaan usein vertailuoperattoreita, ja jos kriteerejä on useita, niin tarvitaan myös useita loogisia operaattoreita. Tarkemmin operaattoreita käsitellään luvussa Loogiset operaattorit. Voit käyttää kyseisen osion taulukkoa apuna jo tässä osiossa. Osajoukkoja voidaan poimia myös suoraan antamalla halutut indeksit esimerkiksi indeksivektorin avulla.\n\n# Filter only females\nstudy_data[study_data$gender == \"female\", ]\n\n  ID height gender weight height_m        BMI\n2  2  184.0 female   65.8    1.840   19.43526\n5  5  169.0 female   58.3    1.690   20.41245\n8  8  161.9 female   62.8    0.169 2198.80256\n\n# Filter individuals whose height is less than or equal to 175\nstudy_data[study_data$height &lt;= 175, ]\n\n   ID height gender weight height_m        BMI\n3   3  173.8   male   49.2    1.738   16.28792\n5   5  169.0 female   58.3    1.690   20.41245\nNA NA     NA   &lt;NA&gt;     NA       NA         NA\n8   8  161.9 female   62.8    0.169 2198.80256\n\n# Filter individuals whose height is not missing and is less than or equal to 175\nstudy_data[!is.na(study_data$height) & study_data$height &lt;= 175, ]\n\n  ID height gender weight height_m        BMI\n3  3  173.8   male   49.2    1.738   16.28792\n5  5  169.0 female   58.3    1.690   20.41245\n8  8  161.9 female   62.8    0.169 2198.80256\n\n# Use multiple filter criteria\nstudy_data[study_data$height &lt;= 175 & study_data$gender == \"female\", ]\n\n  ID height gender weight height_m        BMI\n5  5  169.0 female   58.3    1.690   20.41245\n8  8  161.9 female   62.8    0.169 2198.80256\n\n# Select individuals (rows) 1,3, and 7 directly with a vector of indices\nind &lt;- c(1, 3, 7)\nstudy_data[ind,]\n\n  ID height gender weight height_m      BMI\n1  1  189.8   male   78.2    1.898 21.70773\n3  3  173.8   male   49.2    1.738 16.28792\n7  7     NA   male   74.2    1.818 22.44999",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html#datakehikon-ja-vektorin-järjestäminen",
    "href": "05-data_wrangling.html#datakehikon-ja-vektorin-järjestäminen",
    "title": "5  Datan muokkaaminen",
    "section": "5.4 Datakehikon ja vektorin järjestäminen",
    "text": "5.4 Datakehikon ja vektorin järjestäminen\nYhden vektorin arvot voidaan asettaa nousevaan tai laskevaan järjestykseen funktiolla sort. Funktiota voidaan soveltaa niin numeerisiin kuin merkkitietoa sisältäviin vektoreihinkin. Oletusarvoisesti järjestys on nouseva, eli numeeriset arvot järjestetään pienimmästä suurimpaan ja merkkitieto aakkosjärjestykseen. Järjestyksen voi kääntää laskevaksi argumentilla decreasing = TRUE. Huomaa, että ääkkösten tapauksessa sort ei välttämättä aina järjestä alkioita oikein merkistöstä riippuen.\n\nnums &lt;- c(3, 1, 7, 8, 5, 4)\nchars &lt;- c(\"ab\", \"ca\", \"ac\", \"bb\", \"ba\", \"cb\")\n\n# Ascending order\nsort(nums)\n\n[1] 1 3 4 5 7 8\n\nsort(chars)\n\n[1] \"ab\" \"ac\" \"ba\" \"bb\" \"ca\" \"cb\"\n\n# Descending order\nsort(nums, decreasing = TRUE)\n\n[1] 8 7 5 4 3 1\n\nsort(chars, decreasing = TRUE)\n\n[1] \"cb\" \"ca\" \"bb\" \"ba\" \"ac\" \"ab\"\n\n\nJossain tilanteissa on haluttavaa järjestää datakehikon rivit jonkin muuttujan tai muuttujien suhteen. Tähän tarkoitukseen voi käyttää funktiota order, joka palauttaa yhden tai useamman argumentin alkioiden järjestysluvut (rank). Seuraavassa esimerkissä aineiston rivit järjestetään koehenkilöiden pituuden suhteen nouseevaan suuruusjärjestykseen.\n\nstudy_data[order(study_data$height),]\n\n  ID height gender weight height_m        BMI\n8  8  161.9 female   62.8    0.169 2198.80256\n5  5  169.0 female   58.3    1.690   20.41245\n3  3  173.8   male   49.2    1.738   16.28792\n4  4  175.9   male   71.2    1.759   23.01168\n6  6  183.7   male   54.1    1.837   16.03168\n2  2  184.0 female   65.8    1.840   19.43526\n1  1  189.8   male   78.2    1.898   21.70773\n7  7     NA   male   74.2    1.818   22.44999\n\n\nJärjestäminen voidaan tehdä usean muuttujan suhteen, esimerkiksi pituuden ja painon. Tämä tarkoittaa nousevassa järjestyksessä sitä, että jos kahdella koehenkilöllä on täsmälleen sama pituus, valitaan heidän keskinäinen järjestyksensä painon perusteella. Huomaa sort- ja order-funktioiden ero: sort palauttaa suoraan järjestetyn vektorin kun taas order alkioiden järjestysluvut.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html#faktorit",
    "href": "05-data_wrangling.html#faktorit",
    "title": "5  Datan muokkaaminen",
    "section": "5.5 Faktorit",
    "text": "5.5 Faktorit\nR:n numeeriset vektorit ovat lähtökohtaisesti välimatka- tai suhdeasteikollisia. Olet ehkä ihmetellytkin, miten luokitteluasteikollinen (kategorinen) tai järjestysasteikollinen muuttuja määritellään. Kategorista muuttujaa sanotaan R:ssä faktoriksi. Numeerisen tai tekstimuotoisen muuttujan tai vektorin voi muuttaa faktori-muotoiseksi muuttujaksi factor -funktiolla.\n\n# Let's change gender from character string to a factor and rename it as fgender\nstudy_data$fgender &lt;- factor(study_data$gender)\n\n# Let's now compare the printing of gender and fgender\nstudy_data$gender\n\n[1] \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"female\"\n\nstudy_data$fgender\n\n[1] male   female male   male   female male   male   female\nLevels: female male\n\n\nHuomaa, että faktori tulostaa faktorin tasot eli kaikkien mahdollisten luokkien nimet faktorin perässä: Levels: female male.\nUsein vastaan tulee myös tilanne, jossa faktorin eri tasoja vastaavat kokonaislukuarvot, kuten tässä esimerkissä luvut 1, 2 ja 3. Tällaisessa tilanteessa faktorin tasojen merkitys on usein annettu jossain dokumenttitiedostossa. Tällöin faktorin tasot ja niiden kuvaukset (labels) tulee määrittää käsin.\n\n# Create a data for this example\nwall_dat &lt;- data.frame(\n  building_ID = c(1, 2, 3, 4, 5, 6), \n  building_material = c(1, 1, 2, 2, 3, 3)\n)\n\n# Name is 'building_material' very long, I want to rename it\nnames(wall_dat) &lt;- c(\"building_ID\", \"build_mat\")\n\n# We know from some kind of documentation that 1 stands for \"wood\", 2 is \"steel\" and 3 is \"brick\".\nwall_dat$fbuild_mat &lt;- factor(\n  wall_dat$build_mat,levels = c(1, 2, 3), \n  labels = c(\"wood\", \"steel\", \"brick\")\n)\n\nstr(wall_dat)\n\n'data.frame':   6 obs. of  3 variables:\n $ building_ID: num  1 2 3 4 5 6\n $ build_mat  : num  1 1 2 2 3 3\n $ fbuild_mat : Factor w/ 3 levels \"wood\",\"steel\",..: 1 1 2 2 3 3\n\n\nFaktorimuuttujan kuvaukset siis kertovat, mitä varsinaiset tasoarvot tarkoittavat.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "05-data_wrangling.html#extra-lääketutkimusesimerkki",
    "href": "05-data_wrangling.html#extra-lääketutkimusesimerkki",
    "title": "5  Datan muokkaaminen",
    "section": "5.6 Extra: Lääketutkimusesimerkki",
    "text": "5.6 Extra: Lääketutkimusesimerkki\nR:ssä on aiemmin nähtyjen numeric-, character- ja logical-tyyppien lisäksi muitakin vektoriluokkia, joista tärkein on factor eli faktori. Faktoreihin tallennetaan kategorisia muuttujia, kuten tutkimuksessa määrättyjä ryhmiä, aikapisteitä tms. Luodaan esimerkiksi faktori, jossa on kuvitteellisen lääketutkimuksen osallistujien ryhmätiedot:\n\ngroups &lt;- as.factor(\n  c(\n    \"drug1\", \"drug2\", \"control\", \"drug1\", \"control\",\n    \"drug2\", \"drug2\", \"control\", \"control\", \"drug1\"\n  )\n)\ngroups\n\n [1] drug1   drug2   control drug1   control drug2   drug2   control control\n[10] drug1  \nLevels: control drug1 drug2\n\n\nFactoreita voi luoda muista vektoreista funktioilla factor tai as.factor. as.factor muuntaa vektorin automaattisesti ja nopeasti factoriksi, ja säilyttää myös jo valmiiksi faktoriluokan vektorien tasojen järjestyksen (tästä lisää pian).\nKuten tulosteesta nähdään, faktorin tulostus tulostaa faktorin alkiot (HUOM: ei lainausmerkkejä) sekä faktorin tasot. Faktorit ovat pinnan alla kokonaisluku- eli integer-vektoreita, joissa on päällä “kerros”, joka määrittää factorin tasot. Edellä nähty vektori groups näyttää siis tältä:\n\nFaktorien tasoille annetaan siis lukuarvot ykkösestä eteenpäin. Oletuksena ensimmäinen taso eli taso 1 on aakkosissa ensimmäinen arvo, tai pienin lukuarvo jos faktori tehdään numeerisista muuttujista. Lukuarvot saa näkyville muuntamalla factorin numeeriseksi vektoriksi:\n\nas.numeric(groups)\n\n [1] 2 3 1 2 1 3 3 1 1 2\n\n\nTasojen järjestyksen voi myös päättää itse. Tämä on tärkeää, sillä kuten pian nähdään, faktorin ensimmäinen taso on monissa tilastollisissa testeissä ns. referenssitaso, johon muita tasoja verrataan. Usein esiintyvä tapaus ovat tutkimukset, joissa ovat ryhmät nimeltä case ja control. Koska case on aakkosissa ennen controllia, R käyttää oletuksen case-ryhmää referenssitasona, ja testaa miten control-ryhmä poikkeaa tästä tasosta, vaikka haluaisimme päinvastaisen määrittelyn. Tasot voi itse määrittää näin:\n\nstudy_groups &lt;- factor(\n  c(\"case\", \"control\", \"control\", \"case\", \"case\"),\n  levels = c(\"control\", \"case\")\n)\nstudy_groups\n\n[1] case    control control case    case   \nLevels: control case\n\n\nNyt tasot ovat oikeassa järjestyksessä!\nKuten aiemmin mainittiin, faktoreita voi tehdä myös numeerisista vektoreista. HUOM: muista, että as.numeric() palauttaa faktorin kokonaislukuarvot, ei alkuperäisiä lukuja. Alkuperäiset luvut saa käyttämällä ensin as.character-funktiota, joka muuttaa faktorin tasot merkkijonovektoriksi.\n\ntime_points &lt;- as.factor(c(0, 0, 1, 1, 5, 5, 1, 0, 5))\ntime_points\n\n[1] 0 0 1 1 5 5 1 0 5\nLevels: 0 1 5\n\n# Probably not what you expect\nas.numeric(time_points)\n\n[1] 1 1 2 2 3 3 2 1 3\n\n# First to character, then to numeric\nas.numeric(as.character(time_points))\n\n[1] 0 0 1 1 5 5 1 0 5",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datan muokkaaminen</span>"
    ]
  },
  {
    "objectID": "06-statistics.html",
    "href": "06-statistics.html",
    "title": "6  Tunnusluvut",
    "section": "",
    "text": "6.1 Sijaintia kuvaavat tunnusluvut",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tunnusluvut</span>"
    ]
  },
  {
    "objectID": "06-statistics.html#sijaintia-kuvaavat-tunnusluvut",
    "href": "06-statistics.html#sijaintia-kuvaavat-tunnusluvut",
    "title": "6  Tunnusluvut",
    "section": "",
    "text": "6.1.1 Minimi ja maksimi\nMinimi tarkoittaa aineiston pienintä arvoa kyseiselle muuttujalle. Maksimi on vastaavasti suurin arvo. Minimi ja maksimi ovat periaatteessa helppo laskea funktioiden min ja max avulla, mutta niihinkin liittyy pari pientä sudenkuoppaa. Funktiot min ja max hyväksyvät argumenteikseen vain numeerisia vektoreita.\n\ndat_for_loc &lt;- c(-1.25, -4.1, 1.16, -3.05, 4.17, 0.73, -3.14, 3.39, -2.55, 0.4)\nmin(dat_for_loc)\n\n[1] -4.1\n\nmax(dat_for_loc)\n\n[1] 4.17\n\n\n\nJoskus minimiä ja maksimia tarvitaan tilanteessa, jossa halutaan vaikkapa muuttaa kaikki negatiiviset arvot nolliksi (tai positiiviset, jos maksimi). Tämä onnistuu helpoiten funktioiden pmin ja pmax avulla. Samalla tapaa, jos halutaan kaikki lukua 1 pienemmät luvut muutettua luvuksi 1, niin tämä onnistuu vaihtamalla toinen argumentti luvuksi 1.\n\n# We want to get rid of all values below 0 and make them 0\npmin(dat_for_loc, 0)\n\n [1] -1.25 -4.10  0.00 -3.05  0.00  0.00 -3.14  0.00 -2.55  0.00\n\n# Similar, but get rid of all values over 0\npmax(dat_for_loc, 0)\n\n [1] 0.00 0.00 1.16 0.00 4.17 0.73 0.00 3.39 0.00 0.40\n\n# We can do similar things to any limit, e.g. 1\npmin(dat_for_loc, 1)\n\n [1] -1.25 -4.10  1.00 -3.05  1.00  0.73 -3.14  1.00 -2.55  0.40\n\n\nFunktiota pmin ja pmax voi käyttää vieläkin yleisemmässä muodossa antamalla yksittäisen lukuarvon sijasta vektorin. Näitä emme käsittele tässä, mutta kiinnostuneet voivat kokeilla lisää itse.\n\n\n6.1.2 Keskiarvo\nKeskiarvo saadaan laskemalla muuttujan kaikki havainnot yhteen ja jakamalla summa havaintojen määrällä. Esimerkiksi aineiston \\(1,2,3,4\\) keskiarvo on \\((1+2+3+4)/4 = 2.5\\). Keskiarvoa satunnaismuuttujan \\(X\\) havainnoille voidaan merkitä matemaattisesti seuraavasti:\n\\[\n  \\overline{x} = \\frac1n \\sum_{i=1}^n x_i = \\frac{x_1+x_2+\\dots+x_n}{n},\n\\] missä merkintä \\(\\overline{x}\\) tarkoittaa keskiarvoa, \\(x_1,\\ldots,x_n\\) ovat havaintoja ja \\(n\\) on havaintojen määrä.\nKeskiarvo voidaan laskea helposti funktiolla mean.\n\ntooth_length &lt;- ToothGrowth$len\nmean(tooth_length)\n\n[1] 18.81333\n\n\nMikäli muuttujassa on puuttuvia arvoja (NA) niin keskiarvoksi tulee oletusarvoisesti NA. Puuttuvat arvot voi jättää pois keskiarvon laskennasta antamalla funktiolle lisäargumentiksi na.rm = TRUE.\n\n# Create some data\ndat_for_mean &lt;- c(1, 2, NA, 4)\n# Data with NA results mean with NA\nmean(dat_for_mean)\n\n[1] NA\n\n# Leave NA-values out and calculate mean from the remaining ones\nmean(dat_for_mean, na.rm = TRUE)\n\n[1] 2.333333\n\n\n\n\n6.1.3 Mediaani\nMediaani ilmaisee aineiston keskimmäisen havainnon. Toisin sanoen puolet havainnoista on mediaania suurempia ja puolet mediaania pienempiä. Esimerkiksi aineiston \\(1, 1, 2, 3, 5\\) mediaani on \\(2\\). Jos aineistossa on parillinen määrä lukuja, otetaan kaksi keskimmäistä ja lasketaan ne yhteen ja jaetaan kahdella (keskiarvo). Aineiston \\(3, 3, 5, 6, 7, 17\\) mediaani on \\((5 + 6) / 2 = 5.5\\). Mediaani on helppoa laskea funktiolla median.\n\n# Let's think about median\ndat_for_median &lt;- c(7, 2, 3, 4, 1, 7, 0, 4, 3, 3, 2, 6)\ndat_for_median\n\n [1] 7 2 3 4 1 7 0 4 3 3 2 6\n\nsort(dat_for_median) # Median would be the middle value in the arranged data, thus 3\n\n [1] 0 1 2 2 3 3 3 4 4 6 7 7\n\n# Getting median in R\nmedian(dat_for_median)\n\n[1] 3\n\n\n\n\n6.1.4 Kvantiilit\nMediaani siis kertoi kohdan, jossa 50 % aineistosta on pienenmpiä kuin kyseinen arvo. Entä jos haluamme luvun, jota pienempiä ovat vaikkapa 10 % aineiston havainnoista tai mikä tahansa muu osuus? Tällainen yleistys on nimeltään kvantiili. Joillakin kvantiileilla on erityisnimet. Ne ovat\n\nmediaani (50 % aineistosta on tätä pienempiä)\nalakvartiili (25 %)\nyläkvartiili (75 %)\ndesiilit (10% välein)\n\n10 %:n desiili, 20 %:n desiili jne.\n\n\nHaluamansa kvantiilin voi laskea funktiolla quantile. Jos haluat laskea 30 %:n kvantiilin, niin arnna argumentille probs tätä vastaava suhteellinen osuus eli 0.30.\n\nquantile(dat_for_median, probs = 0.30)\n\n30% \n2.3 \n\n\nquantile-funktiolle voi antaa useita kvantiileita laskettavaksi kerralla. Tällöin argumentille probs on annettava vektori. Esimerkiksi kvartiilit ja mediaanin voi laskea samanaikaisesti näin:\n\nquantile(dat_for_median, probs = c(0.25, 0.5, 0.75))\n\n25% 50% 75% \n2.0 3.0 4.5 \n\n\nÄäritapauksena voidaan havaita, että laskemalla 0 %:n ja 100 %:n kvantiilit saadaan tulokseksi minimi ja maksimi (yksikään arvo ei ole minimiä pienempi eikä yksikään maksimia suurempi. Samaan lopputulokseen pääsee myös funktiolla range. Kokeillaan tätä\n\n# 0 % and 100 % quantile gives a range of the data\nquantile(dat_for_median, probs = c(0.00, 1.00))\n\n  0% 100% \n   0    7 \n\n# Let's compare with min and max\nmin(dat_for_median)\n\n[1] 0\n\nmax(dat_for_median)\n\n[1] 7\n\n# There is also function called range\nrange(dat_for_median)\n\n[1] 0 7\n\n\nEsimerkiksi viiksilaatikkokuvaa vastaavat lukuarvot eli minimin, alakvartiilin, mediaanin, yläkvartiilin ja maksimin saa kätevästi quantile-funktiolla antamalla probs-argumentille vektorin c(0, 0.25, 0.5, 0.75, 1). Tätä sanotaan joskus viiden numeron yhteenvedoksi.\n\nquantile(dat_for_median, probs = c(0, 0.25, 0.5, 0.75, 1))\n\n  0%  25%  50%  75% 100% \n 0.0  2.0  3.0  4.5  7.0 \n\n\n\n\n6.1.5 Moodi\nMoodi ilmaisee muuttujan yleisimmän arvon. Valitettavasti R:ssä ei ole valmista funktiota moodin laskemiseen. Sen sijaan funktio nimeltään mode antaa objektin tyypin, eikä laske moodia. Jos moodin haluaa laskea R:ssä, on ensin muodostettava aineistosta frekvenssitaulukko ja sitten etsittävä taulokosta se arvo, josta on eniten havaintoja, eli suurin frekvenssi\n\n# Find out the mode\ndat_for_mode &lt;- c(\n  7, 2, 3, 4, 1, 7, 0, 4, 3, 3, 2, 6, 1, 3, 3, 1, 6, 0, 1, 3, \n  0, 6, 4, 2, 3, 2, 2, 7, 3, 1, 5, 3, 4, 3, 3, 2, 2, 4, 2, 1, \n  5, 3, 2, 2, 2, 3, 4, 2, 5, 3, 4, 2, 1, 4, 2, 3, 1, 1, 4, 3, \n  2, 3, 5, 4, 4, 4, 1, 3, 1, 3, 5, 2, 3, 1, 4, 2, 4, 2, 1, 0, \n  3, 3, 3, 3, 4, 4, 4, 3, 4, 4, 2, 1, 2, 4, 4, 4, 6, 2, 3, 2\n)\ntab &lt;- table(dat_for_mode)\n# Let's see how is tab\ntab\n\ndat_for_mode\n 0  1  2  3  4  5  6  7 \n 4 14 22 26 22  5  4  3 \n\n# Let's pick up the largest frequency using which.max function\ntab[which.max(tab)]\n\n 3 \n26 \n\n# Mode is 3 and the frequency is 26\n# Let's pick up only the value 3\nnames(tab)[which.max(tab)]\n\n[1] \"3\"\n\n# That is character so let's convert it to numeric\nas.numeric(names(tab)[which.max(tab)])\n\n[1] 3\n\n\nYlläoleva on hyvä esimerkki tilanteesta, jossa moodin laskemiseen käytetty koodi on kätevä kirjoittaa funktioksi, jolloin moodi on helppo laskea jatkossa toisilla aineistoilla. Funktiohin palataan osiossa Funktiot. Alla on joka tapauksessa esimerkki moodi-funktiosta ilman suurempia selityksiä. Huom! tämä moodi-funktio toimii vain numeerisille vektoreille.\n\n# Write a function for mode\nmoodi &lt;- function(x) {\n  tab &lt;- table(x)\n  as.numeric(names(tab)[which.max(tab)])\n}\n# Use that function\nmoodi(dat_for_mode)\n\n[1] 3\n\n# NOTE! This only works for numeric data!\ndat_for_mode_character &lt;- c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\")\n# This gives NA as output and a warning!\nmoodi(dat_for_mode_character)\n\nWarning in moodi(dat_for_mode_character): NAs introduced by coercion\n\n\n[1] NA",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tunnusluvut</span>"
    ]
  },
  {
    "objectID": "06-statistics.html#yhteenveto-aineistosta-summary",
    "href": "06-statistics.html#yhteenveto-aineistosta-summary",
    "title": "6  Tunnusluvut",
    "section": "6.2 Yhteenveto aineistosta (summary)",
    "text": "6.2 Yhteenveto aineistosta (summary)\nKätevä tapa saada nopea yhteenveto datakehikon kaikista muuttujista on soveltaa summary-funktiota datakehikkoon.\n\n# Calculate summary for ToothGrowth data\nsummary(ToothGrowth)\n\n      len        supp         dose      \n Min.   : 4.20   OJ:30   Min.   :0.500  \n 1st Qu.:13.07   VC:30   1st Qu.:0.500  \n Median :19.25           Median :1.000  \n Mean   :18.81           Mean   :1.167  \n 3rd Qu.:25.27           3rd Qu.:2.000  \n Max.   :33.90           Max.   :2.000  \n\n\nsummary huolii myös yksittäisen vektorin, jolloin yhteenveto tulostuu vaakasuuntaisena.\n\ntooth_length &lt;- ToothGrowth$len\nsummary(tooth_length)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   4.20   13.07   19.25   18.81   25.27   33.90",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tunnusluvut</span>"
    ]
  },
  {
    "objectID": "06-statistics.html#varianssi-ja-keskihajonta",
    "href": "06-statistics.html#varianssi-ja-keskihajonta",
    "title": "6  Tunnusluvut",
    "section": "6.3 Varianssi ja keskihajonta",
    "text": "6.3 Varianssi ja keskihajonta\nYksittäiselle numeeriselle muuttujalle voidaan laskea varianssi funktiolla var. Varianssia tulkittaessa kannattaa muistaa, että varianssin mittayksikkö ei ole sama kuin alkuperäisen muuttujan, vaan mittayksikkö tulee korottaa toiseen potenssiin. Esim. jos pituuden yksikkö on cm, niin pituuden varianssin yksikkö on \\(\\text{cm}^2\\). Käytännössä tulkintaa kannattaa yrittää keskihajonnan avulla.\n\n# pull the variable from data frame and use it directly in function var\nvar(ToothGrowth$len)\n\n[1] 58.51202\n\n# calculate the variance-covariance matrix for entire data frame \n# (gives NA to any pairs with categorical variables)\n# variances are obtained from the diagonal (58.51, NA, 0.3954)\nvar(ToothGrowth)\n\nWarning in var(ToothGrowth): NAs introduced by coercion\n\n\n           len supp      dose\nlen  58.512023   NA 3.8612994\nsupp        NA   NA        NA\ndose  3.861299   NA 0.3954802\n\n\nKeskihajonta (engl. standard deviation) saadaan vastaavasti funktiolla sd. Keskihajonta on varianssin neliöjuuri.\n\n# standard deviation\nsd(ToothGrowth$len)\n\n[1] 7.649315",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Tunnusluvut</span>"
    ]
  },
  {
    "objectID": "07-distributions.html",
    "href": "07-distributions.html",
    "title": "7  Todennäköisyysjakaumat",
    "section": "",
    "text": "7.1 Esimerkki: normaalijakauma\nOletetaan, että suomalaisten miesten suolan saanti on normaalijakautunut odotusarvolla 10 grammaa päivässä ja keskihajonta on 4 grammaa päivässä (odotusarvo on totta, keskihajonta allekirjoittaneen hihasta). Piirretään ensin kuva jakaumasta välillä \\([0, 20]\\) grammaa päivässä. Jakauman muoto saadaan funktiolla dnorm, eli yllä olevan ohjeen mukaan d-alkuinen funktio antaa tiheysfunktion, ja norm-pääte viittaa normaalijakaumaan. Normaalijakauman funktiolle tulee kertoa jakauman odotusarvo (mean) ja keskihajonta (sd).\n# Sequential vector  of salt consumption\nsalt &lt;- seq(0, 20, by = 0.1)\n# Density function\ndensity &lt;- dnorm(salt, mean = 10, sd = 4)\n# Line plot\nplot(\n  salt, density, type = \"l\",\n  xlab = \"Suolan saanti\", \n  ylab = \"Tiheys\",\n  main = \"Suomalaisten miesten suolan saanti\"\n)\nAikuisten saantisuositus on enintään 5 grammaa suolaa päivässä. Kuinka moni suomalainen mies syö tämän jakauman mukaan sopivasti suolaa? Vastaus saadaan kertymäfunktiosta todennäköisyytenä \\(P(X \\leq 5)\\) pnorm-funktion avulla.\npnorm(5, mean = 10, sd = 4)\n\n[1] 0.1056498\nTämän jakauman mukaan vain noin 11 % suomalaisista miehistä syö suolaa sopivasti!\nSuomalaisten naiset syövät keskimäärin 7 grammaa suolaa päivässä. Kuinka moni mies syö tätä enemmän suolaa? pnorm antaa oletuksena arvon \\(P(X \\leq 7)\\). Nyt halutaan kuitenkin tietää \\(P(X &gt; 7)\\), joka saadaan asettamalla lower.tail = FALSE:\npnorm(7, mean = 10, sd = 4, lower.tail = FALSE)\n\n[1] 0.7733726\nNoin 77 % miehistä syö suolaa keskimääräistä naista enemmän.\nEntä jos halutaan tietää, kuinka paljon suolaa eniten syövä 10 % vähintään saa? Tähän voidaan vastata funktiolla qnorm, joka on jakauman käänteinen kertymäfunktio, eli funktion pnorm käänteisfunktio. Samoin kuin pnorm, qnorm-funktion oletus on, että todennäköisyydet lasketaan jakauman vasemmasta hännästä alkaen. Vastaus tähän kysymykseen selviää siis näillä kahdella tavalla:\nqnorm(0.1, mean = 10, sd = 4, lower.tail = FALSE)\n\n[1] 15.12621\n\nqnorm(0.9, mean = 10, sd = 4)\n\n[1] 15.12621\nEli tämän jakauman mukaan eniten suolaa saava 10 % miehistä syö yli kolminkertaisen määrän suolaa suositukseen verrattuna.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Todennäköisyysjakaumat</span>"
    ]
  },
  {
    "objectID": "07-distributions.html#muita-jakaumia",
    "href": "07-distributions.html#muita-jakaumia",
    "title": "7  Todennäköisyysjakaumat",
    "section": "7.2 Muita jakaumia",
    "text": "7.2 Muita jakaumia\nVastaavat funktiot löytyvät myös muille jakaumille, kuten:\n\nKhiin neliö: chisq\nEksponentiaalinen: exp\nStudentin \\(t\\): t\nTasajakauma: unif\nPoisson: pois\nBinomijakauma: binom\n\nja niin edelleen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Todennäköisyysjakaumat</span>"
    ]
  },
  {
    "objectID": "08-plots.html",
    "href": "08-plots.html",
    "title": "8  Kuvaajien piirtäminen",
    "section": "",
    "text": "8.1 Korkean tason piirtofunktiot",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Kuvaajien piirtäminen</span>"
    ]
  },
  {
    "objectID": "08-plots.html#korkean-tason-piirtofunktiot",
    "href": "08-plots.html#korkean-tason-piirtofunktiot",
    "title": "8  Kuvaajien piirtäminen",
    "section": "",
    "text": "8.1.1 plot\nKorkean tason piirtofunktioista ylivoimaisesti yleisin on plot. plot-funktio on hyvin monipuolinen, mutta sen yleisin käyttötarkoitus on piirtää hajontakuvio (scatter plot) yhdestä tai kahdesta vektorista. Alla on hajontakuvio auton jarrutusmatkoista eri nopeuksilla:\n\n# Car speeds (km/h)\nspeed &lt;- seq(40, 110, by = 10)\n# Stopping distances (m)\nstop_dist &lt;- c(26, 35, 45, 56, 69, 83, 98, 113)\n# Draw the plot\nplot(x = speed, y = stop_dist)\n\n\n\n\n\n\n\n\nplot-funktiolle annetaan siis kaksi yhtä pitkää vektoria, joissa ovat pisteiden \\(x\\)- ja \\(y\\)-koordinaatit. Halutessaan kuvalle voi antaa otsikon (title) ja nimetä uudestaan kuvan akselit (axis labels). Tämä onkin usein hyvä idea, sillä R:n muuttujien nimissä ei saa olla välilyöntejä tai erikoismerkkejä, mutta usein näiden käyttö akselien nimissä on hyvin informatiivista.\n\nplot(\n  x = speed, \n  y = stop_dist,\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\n\n\n\n\n\n\n\n\nplot-funktiolle voi antaa muitakin argumentteja, jotka säätävät mm. pisteiden väriä, kokoa ja muotoa, akselien rajoja jne. Yleisiä kuvaajien parametreja voi säätää funktiolla par (graphical parameters).\n\n\n8.1.2 Muut korkean tason funktiot\nTässä on esimerkkejä muutamista muista yleisistä korkean tason funktioista:\nhist piirtää histogrammeja. Histogrammit kuvaavat jatkuvan muuttujan jakaumaa.\n\n# A vector of 1000 observations from a normal distribution of heights of Finnish women\nheights &lt;- rnorm(n = 1000, mean = 168, sd = 5.4)\nhist(\n  heights, \n  breaks = 20, \n  main = \"Suomalaisten naisten pituuksien jakauma\",\n  xlab = \"Pituus (cm)\", \n  ylab = \"Frekvenssi\"\n)\n\n\n\n\n\n\n\n\nToinen tapa kuvata jatkuvan muuttujan jakaumaa on viiksilaatikko (joskus myös laatikko-viikset -kuvaaja), joita piirretään boxplot-funktiolla:\n\nboxplot(\n  heights, \n  breaks = 20, \n  main = \"Suomalaisten naisten pituuksien jakauma\",\n  ylab = \"Pituus (cm)\"\n)\n\n\n\n\n\n\n\n\nVastaavasti diskreetin muuttujan jakaumaa voi kuvata pylväsdiagrammilla käyttäen barplot-funktiota. Alla on esimerkki opiskelijoiden kotipaikkakuntien jakaumasta. Tässä tulee myös tutuksi tärkeä vektorien ominaisuus: nimeäminen. Nimettyjen vektorien (named vectors) alkioilla on järjestyslukujen lisäksi nimet. Nimet annetaan olla olevaan tyyliin nimi = alkio. Nimetyt vektori käyttäytyvät aivan kuin tavalliset vektorit, mutta niitä voi indeksoida myös nimien avulla, ja jotkut funktiot, kuten barplot, käyttävät hyödyksi alkioiden nimiä. Nimettyjen vektorien käyttö ei ole kurssin ydinasioita, mutta tämä on hyödyllistä osata.\n\norigin &lt;- c(\n  \"Pohjois-Savo\" = 15, \n  \"Pk-seutu\" = 10, \n  \"Turku\" = 3,\n  \"Pohjois-Suomi\" = 8\n)\norigin\n\n Pohjois-Savo      Pk-seutu         Turku Pohjois-Suomi \n           15            10             3             8 \n\norigin[\"Turku\"]\n\nTurku \n    3 \n\nbarplot(\n  origin, \n  main = \"Opiskelijoiden kotipaikkakunta\",\n  ylab = \"Opiskelijoiden lukumäärä\"\n)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Kuvaajien piirtäminen</span>"
    ]
  },
  {
    "objectID": "08-plots.html#alemman-tason-grafiikkatoiminnot",
    "href": "08-plots.html#alemman-tason-grafiikkatoiminnot",
    "title": "8  Kuvaajien piirtäminen",
    "section": "8.2 Alemman tason grafiikkatoiminnot",
    "text": "8.2 Alemman tason grafiikkatoiminnot\nAlemman tason grafiikkatoiminnoilla voi lisätä olemassa olevaan kuvaan lisää osia, kuten tekstiä, pisteitä tai selitteen (legend).\nOtetaan esimerkiksi alussa nähty kuvaaja autojen pysähtymismatkoista ja lisätään siihen uusia osia. Tässä vielä alkuperäinen kuva:\n\nplot(\n  x = speed, \n  y = stop_dist,\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\n\n\n\n\n\n\n\n\nLisätään kuvaajan jarrutusmatkat liukkaalla kelillä. Uusia pisteitä voi piirtää points-funktiolla, jolle annetaan \\(x\\)- ja \\(y\\)-koordinaatit vektoreina ihan kuin plot-funktiollekin.\n\nstop_dist_wet &lt;- c(30, 41, 54, 69, 85, 103, 122, 143)\nplot(\n  x = speed, \n  y = stop_dist,\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet)\n\n\n\n\n\n\n\n\nYlläolevassa kuvaajassa on kaksi ongelmaa: ylimmät pisteet eivät näy, koska kuvaajan y-akseli loppuu kesken. \\(y\\)-akseli on piirretty alkuperäisten jarrutusmatkojen pohjalta, ja koska liukkaalla kelillä jarrutus kestää pidempään, uudet pisteet eivät mahdu kuvaajaan. Toinen ongelma on se, että pisteitä ei voi erottaa toisistaan.\nEnsimmäinen ongelma ratkeaa säätämällä käsin \\(y\\)-akselin rajat. Tämä tapahtuu argumentilla ylim, jolle annetaan vektorissa ylä- ja alaraja (vastaavasti xlim säätää \\(x\\)-akselin rajat).\nLisäksi piirretään selvyyden vuoksi pisteet eri värisinä ja eri kuvioilla. Argumentti col säätää pisteiden värin ja pch pisteiden muodon. Eri väri- ja muotovaihtoehdot löytyvät googlaamalla.\n\nplot(\n  x = speed, \n  y = stop_dist,\n  col = \"darkblue\", \n  pch = 20,\n  ylim = c(20, 150),\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet, pch = 15, col = \"darkred\")\n\n\n\n\n\n\n\n\nNyt kuvaaja alkaa jo näyttää paremmalta, mutta kuvaajasta ei vielä voi päätellä, mitä eri väriset pisteet tarkoittavat. Lisätään siis kuvaajaan selite legend-komennolla. Selitteelle määritetään paikka kuvaajassa x ja y argumenteilla (vasemman yläkulman koordinaatit). Sen jälkeen annetaan selitetekstit (legend), sekä selitteen muodot ja värit (pch ja col, kuten aiemmin). HUOM! Selitteen symbolit ja värit on itse osattava laittaa oikeaan järjestykseen. Selitteen tekstit annetaan järjestyksessä ylhäältä alas, ja piirtomerkit tulee antaa samassa järjestyksessä.\n\nplot(\n  x = speed, \n  y = stop_dist,\n  col = \"darkblue\", \n  pch = 20,\n  ylim = c(20, 150),\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet, pch = 15, col = \"darkred\")\nlegend(\n  x = 40, \n  y = 150,\n  legend = c(\"Märkä keli\", \"Kuiva keli\"),\n  pch = c(15, 20), \n  col = c(\"darkred\", \"darkblue\")\n)\n\n\n\n\n\n\n\n\nSäädetään kuvaajaa vielä hiukan, ja lisätään siihen käyrä kuvaamaan jarrutusmatkan ennustetta lines-funktiolla.\nAlla olevassa koodissa lasketaan ensin lm-funktion avulla sopivat parametrit käyrälle. Lineaarisia malleja käsitellään vasta kappaleessa lineaariset mallit, joten tässä vaiheessa niistä ei tarvitse vielä ymmärtää muuta kuin se, että lm-funktio sovittaa lineaarisen mallin (tässä tapauksessa muotoa \\(\\text{matka} = a + b \\cdot \\text{nopeus} + c \\cdot \\text{nopeus}^2)\\), jonka perusteella voidaan ennustaa pysähtymismatkaa myös muille kuin mitatuille nopeuksille.\n\n# Create vector of squared speeds to fit second order polynomial\nspeed_squared &lt;- speed^2\n\n# Model for dry weather\nmodel_dry &lt;- lm(stop_dist ~ speed + speed_squared)\nprediction_dry &lt;- model_dry$fitted.values\n\n# Model for rainy weather\nmodel_wet &lt;- lm(stop_dist_wet ~ speed + speed_squared)\nprediction_wet &lt;- model_wet$fitted.values\n\nlines tarvitsee x ja y argumentit kuten points, mutta piirtää viivan, ei pisteitä. Käytetään äsken laskettuja mallien antamia ennusteita (prediction-vektoreita) \\(y\\)-koordinaatteina. Tehdään viivoista katkoviivoja argumentilla lty = \"dashed\" (lty eli line type).\n\nplot(\n  x = speed, \n  y = stop_dist,\n  col = \"darkblue\", \n  pch = 20,\n  ylim = c(20, 150),\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", \n  ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet, pch = 15, col = \"darkred\")\nlegend(\n  x = 40, \n  y = 150,\n  legend = c(\"Märkä keli\", \"Kuiva keli\"),\n  pch = c(15, 20), \n  col = c(\"darkred\", \"darkblue\")\n)\nlines(speed, prediction_dry, lty = \"dashed\")\nlines(speed, prediction_wet, lty = \"dashed\")\n\n\n\n\n\n\n\n\nSeuraavaksi voidaan värittää käyrät samoilla väreillä kuin pisteet, ja lisätä niille omat selitteet. Tässä vaiheessa selitteen tekemisestä tulee jo melko monimutkaista, sillä selitteessä on mukana pisteitä ja käyriä. Tästä syystä selitteen argumentteihin pitää laittaa puuttuvia arvoja pch ja lty-argumenteille, koska selitteen ensimmäiset rivit eivät viittaa mihinkään käyrään, vaan pelkästään pisteisiin ja vastaavasti kaksi alinta riviä viittaavat vain käyriin.\n\nplot(\n  x = speed, \n  y = stop_dist,\n  col = \"darkblue\",\n  pch = 20,\n  ylim = c(20, 150),\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\",\n  ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet, pch = 15, col = \"darkred\")\nlegend(\n  x = 40, \n  y = 150,\n  legend = c(\n    \"Märkä keli\", \n    \"Kuiva keli\",\n    \"Ennuste märälle kelille\",\n    \"Ennuste kuivalle kelille\"\n  ),\n  pch = c(15, 20, NA, NA),\n  lty = c(NA, NA, \"dashed\", \"dashed\"),\n  col = c(\"darkred\", \"darkblue\", \"darkred\", \"darkblue\")\n)\nlines(speed, prediction_dry, lty = \"dashed\", col = \"darkblue\")\nlines(speed, prediction_wet, lty = \"dashed\", col = \"darkred\")\n\n\n\n\n\n\n\n\nKuvaajamme on melkein valmis iltapäivälehteen muistuttamaan liukkaiden kelien vaaroista, mutta jotta siitä tulisi oikein säväyttävä, siinä pitää toki olla tekstiä! Lisätään siis vielä pieni tekstin pätkä, joka korostaa eroa liukkaan ja kuivan kelin välillä. Tekstiä voi lisätä text-funktiolla, jolle annetaan tuttuun tapaan x ja y-argumentit, joilla määritetään tekstin paikka ja labels määrittää itse tekstin (kaikki argumentit voivat olla myös pidempiä vektoreita, jolloin tulee useampi teksti eri paikkoihin). Lisäksi parametrillä adj (adjust) voi hienosäätää tekstin paikkaa. adj on vektori, jossa on hienosäätöarvot \\(x\\)- ja \\(y\\)-suunnissa.\n\nplot(\n  x = speed, \n  y = stop_dist,\n  col = \"darkblue\",\n  pch = 20,\n  ylim = c(20, 150),\n  main = \"Auton pysähtymismatka eri nopeuksilla\",\n  xlab = \"Auton nopeus (km / h)\", ylab = \"Pysähtymismatka (m)\"\n)\npoints(x = speed, y = stop_dist_wet, pch = 15, col = \"darkred\")\nlegend(\n  x = 40, \n  y = 150,\n  legend = c(\n    \"Märkä keli\", \n    \"Kuiva keli\",\n    \"Ennuste märälle kelille\",\n    \"Ennuste kuivalle kelille\"\n  ),\n  pch = c(15, 20, NA, NA),\n  lty = c(NA, NA, \"dashed\", \"dashed\"),\n  col = c(\"darkred\", \"darkblue\", \"darkred\", \"darkblue\")\n)\nlines(speed, prediction_dry, lty = \"dashed\", col = \"darkblue\")\nlines(speed, prediction_wet, lty = \"dashed\", col = \"darkred\")\ntext(x = 95, y = 145, labels = \"ERO JOPA 30 METRIÄ!\") \n\n\n\n\n\n\n\n\nKuvaajamme on nyt valmis!",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Kuvaajien piirtäminen</span>"
    ]
  },
  {
    "objectID": "08-plots.html#kuvaajien-piirtäminen-käytännössä",
    "href": "08-plots.html#kuvaajien-piirtäminen-käytännössä",
    "title": "8  Kuvaajien piirtäminen",
    "section": "8.3 Kuvaajien piirtäminen käytännössä",
    "text": "8.3 Kuvaajien piirtäminen käytännössä\nJos äskeisen esimerkin aikana tuntui siltä, että näimme paljon vaivaa ja saimme lopputulokseksi kuvaajan, joka ei oikeastaan edes näytä kovin hyvältä, olet aivan oikeassa. Kuvaajien rakentaminen itse R:n peruskomennoilla on raskasta, ja usein perusgrafiikkatoimintoja käytetään lähinnä omaan käyttöön tulevien kuvaajien piirtämiseen nopeasti. Peruskomennot on kuitenkin hyvä hallita, sillä niitä saattaa tarvita valmiilla työkaluilla tehtyjen kuvaajien muokkaamiseen. Varsinkin tekstin lisääminen, sekä akselien nimeäminen ja otsikon muuttaminen ovat hyviä taitoja osata.\nR tarjoaa paljon valmiita työkaluja erilaisten kuvaajien piirtämiseen. Valitettavasti tällä kurssilla ei ole aikaa sukeltaa näiden työkalujen käyttöön, sillä ennen niiden käyttöä pitää ymmärtää enemmän R:n monimutkaisemmista tietorakenteista, joita käsitellään seuraavilla viikoilla. Inspiraatiota ja motivaatiota voi kuitenkin hakea esimerkiksi R Graph Gallery-sivulta tai ggpubr-paketin ohjeista. R:n ehdottomasti monipuolisin ja kehitetyin työkalu kuvien piirtämiseen on ggplot2 paketti.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Kuvaajien piirtäminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html",
    "href": "09-statistical_tests.html",
    "title": "9  Tilastollinen testaaminen",
    "section": "",
    "text": "9.1 Testaamisen periaatteita\nTilastollisilla testeillä pyritään arvioimaan perusjoukkoa koskevien väiteiden paikkansapitävyyttä todennäköisyyslaskennan keinoin. Lähtökohtana on niin sanottu nollahypoteesi (\\(H_0\\)), joka yleensä vastaa tilannetta, jossa mahdolliset väitettä tukevat haivainnot ovat vain sattuman seurausta. Esimerkiksi jos tutkitaan onko jokin lääkeaine tehokas hoitokeino, voisi nollahypoteesi olla muotoa “lääkeaineella ei ole vaikutusta”. Nollahypoteesiin liittyy aina vastahypoteesi (\\(H_1\\)), joka yleensä nollahypoteesin vastakohta, ja vastaa mielenkiinnon kohteena olevaa väitettä (esim. “lääkeaineella on vaikutusta”).\nTilastolliset testit olettava nollahypoteesin olevan totta, jolloin nollahypoteesin mielessä erittäin harvinaiset tulokset antavat aihetta epäillä nollahypoteesin mielekkyyttä. Testiin liittyy yleensä testisuure, joka on jokin aineistosta laskettu tunnusluku. Testisuureen jakauman perusteella voidaan arvioida todennäköisyyttä, että havaittu tulos olisi vain sattuman seurausta. Tätä todennäköisyyttä kutsutaan p-arvoksi. Perinteisesti tilastotieteessä asetetaan etukäteen jokin riskitaso (\\(\\alpha\\)), ja jos saatu p-arvo on riskitasoa pienempi niin nollahypoteesi hylätään (yleensä \\(\\alpha = 0.05\\)). Jos p-arvo on riskitasoa pienempi, niin havaintoa kutsutaan tilastollisesti merkitseväksi (nykyisin suositellaan myös termiä tilastollisesti erottuva, sillä sana merkitsevä menee usein sekaisin sanan merkittävä kanssa).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html#t-testi",
    "href": "09-statistical_tests.html#t-testi",
    "title": "9  Tilastollinen testaaminen",
    "section": "9.2 \\(t\\)-testi",
    "text": "9.2 \\(t\\)-testi\nStudentin \\(t\\)-testi on yksi tunnetuimmista tilastollisista testeistä. Se testaa yhden tai kahden ryhmän odotusarvoja tietylle muuttujalle.\nTarkastellaan R:n sisäistä dataa sleep, joka sisältää mittauksia muutoksista oppilaiden unen määrässä (muuttuja extra, muutos unen määrässä tunneissa) kahdella eri lääkkeellä (muuttuja group). Jokainen oppilas kokeili kumpaakin lääkettä, muuttuja ID yksilöi oppilaat.\n\n9.2.1 Yhden otoksen \\(t\\)-testi\nTestaamme aluksi hypoteesia, että muutos unen määrässä lääkkeen käytön jälkeen on 0 (\\(H_0 : \\mu = 0\\)). Funktiota t.test voi käyttää monella tapaa. Tässä esimerkissä annamme funktiolle kaavan extra ~ 1, eli ns. formula-objektin ensimmäisenä argumenttina, joka on osa R:n syntaksia tilastollisten mallien ja riippuvuusrakenteiden määrittellyyn. Kaava määrittelee, että ~-merkin vasen puoli on vastemuuttuja, ja oikea puoli sisältää selittävät muuttujat. Koska emme tee testiä minkään toisen muuttujan suhteen, niin kaavan oikean puoli on vain luku 1, joka R:n syntaksissa tarkoittaa, että se on vakio. Tämä ei siis tarkoita esimerkiksi sitä, että nollahypoteesimme olisi, että muutos unen määrässä olisi 1 tunti. Nollahypoteesin mukainen odotusarvo määritellään argumentilla mu, joka yhden otoksen testissä saa oletusarvon 0.\n\n# One sample test\ntt1 &lt;- t.test(extra ~ 1, data = sleep)\ntt1\n\n\n    One Sample t-test\n\ndata:  extra\nt = 3.413, df = 19, p-value = 0.002918\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 0.5955845 2.4844155\nsample estimates:\nmean of x \n     1.54 \n\n\nTuloksena saamme \\(t\\)-testisuureen arvon, vapausasteet sekä testin p-arvon. Koska p-arvo on pieni (perinteisesti rajana käytetään lukua 0.05, mutta tämä vaihtelee tieteenalasta riippuen) niin nollahypoteesi hylätään, eli testin mukaan muutos unen määrässä poikkeaa tilastollisesti merkitsevästi nollasta kumpaa tahansa lääkettä käytettäessä. Tuloste kertoo myös testin vastahypoteesin \\(H_1\\) kohdassa “alternative hypothesis”.\nTestiin liittyvät tunnusluvut (testisuure, vapausasteet ja p-arvo) saamme eriteltyä tulosobjektista tt1 seuraavasti:\n\n# Test statistic\ntt1$statistic\n\n       t \n3.412965 \n\n# Degrees of freedom\ntt1$parameter\n\ndf \n19 \n\n# p-value\ntt1$p.value\n\n[1] 0.00291762\n\n\n\n\n9.2.2 Kahden otoksen \\(t\\)-testi\nEntäpä jos haluammekin testata hypoteesia, että kumpikin lääke vaikuttaa samalla tavalla unen määrään (\\(H_0 : \\mu_1 = \\mu_2\\))? Voimme tässäkin tapauksessa käyttää formula-syntaksia hyödyksi. Vakion 1 sijaan sijoitamme nyt lääkettä vastaavan muuttujan group kaavassa ~-merkin oikealle puolelle.\n\ntt2 &lt;- t.test(extra ~ group, data = sleep)\ntt2\n\n\n    Welch Two Sample t-test\n\ndata:  extra by group\nt = -1.8608, df = 17.776, p-value = 0.07939\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n -3.3654832  0.2054832\nsample estimates:\nmean in group 1 mean in group 2 \n           0.75            2.33 \n\n\nTestiobjektin sisältö vastaa yhden otoksen testiä suurimmilta osin. Näämme, että testin tulos ei tällä kertaa ollut tilastollisesti merkitsevä (merkitsevyystasolla 0.05) eli testin mukaan ei ole näyttöä siitä, että lääkkeet vaikuttaisivat eri tavalla unen määrään, jolloin nollahypoteesia ei hylätä.\nTarkkasilmäinen lukija saattoi kuitenkin huomata, että tämä testi ei aivan vastaa tarkoitusta, sillä sleep-aineistossa jokainen koehenkilö kokeili kumpaakin lääkettä, jolloin oikea tapa olisi testata lääkkeiden vaikutuksen erotusta, sillä mittaukset ovat toisistaan riippuvia. Tehdään tämä seuraavaksi.\n\n\n9.2.3 Riippuvien (parittaisten) otosten \\(t\\)-testi\nJotta mittausparit tulevat otettua huomioon testissä, on t.test-funktiolle annettava argumentti paired = TRUE. Tässä testissä nollahypoteesi on, että lääkkeiden vaikutuksen erotuksen odotusarvo on 0 (\\(H_0 : \\mu_d = 0\\)).\n\ntt3 &lt;- t.test(extra ~ group, data = sleep, paired = TRUE)\ntt3\n\n\n    Paired t-test\n\ndata:  extra by group\nt = -4.0621, df = 9, p-value = 0.002833\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n -2.4598858 -0.7001142\nsample estimates:\nmean difference \n          -1.58 \n\n\nTällä kertaa tulos on taas tilastollisesti merkitsevä, eli lääkkeiden vaikutuksessa unen määrään on tilastollisesti merkitsevä ero, jolloin nollahypoteesi hylätään.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html#khiin-neliö--testi",
    "href": "09-statistical_tests.html#khiin-neliö--testi",
    "title": "9  Tilastollinen testaaminen",
    "section": "9.3 Khiin neliö -testi",
    "text": "9.3 Khiin neliö -testi\nKahden kategorisen muuttujan riippuvuuden tutkimiseen voidaan käyttää khiin neliö -testiä (\\(\\chi^2\\) test). Tyypillisesti halutaan verrata jonkin muuttujan ryhmien välisiä eroja, kuten puoluekannatusta alueittain tai sukupuolten suhteen. Testin ideana on verrata havaittua ristiintaulukkoa nollahypoteesin mukaiseen ristiintaulukkoon, jossa muuttujien välillä ei ole lainkaan riippuvuutta. Khiin neliö -testin testisuure perustuu näiden kahden taulukon eroihin.\nTarkastellaan Yhdysvaltalaista kyselytutkimusaineistoa, joka sisältää tiedon henkilön puoluekannatuksesta ja sukupuolesta. Tutkitaan khiin neliö -testin avulla, riippuuko puoluekannatus sukupuolesta. R:ssä tämä voidaan tehdä funktiolla chisq.test.\n\n## From Agresti(2007) p.39\nM &lt;- as.table(rbind(c(762L, 327L, 468L), c(484L, 239L, 477L)))\ndimnames(M) &lt;- list(\n  gender = c(\"F\", \"M\"),\n  party = c(\"Democrat\", \"Independent\", \"Republican\")\n)\n(Xsq &lt;- chisq.test(M))  # Prints test summary\n\n\n    Pearson's Chi-squared test\n\ndata:  M\nX-squared = 30.07, df = 2, p-value = 2.954e-07\n\nXsq$observed   # observed counts (same as M)\n\n      party\ngender Democrat Independent Republican\n     F      762         327        468\n     M      484         239        477\n\nXsq$expected   # expected counts under the null\n\n      party\ngender Democrat Independent Republican\n     F 703.6714    319.6453   533.6834\n     M 542.3286    246.3547   411.3166\n\nXsq$residuals  # Pearson residuals\n\n      party\ngender   Democrat Independent Republican\n     F  2.1988558   0.4113702 -2.8432397\n     M -2.5046695  -0.4685829  3.2386734\n\nXsq$stdres     # standardized residuals\n\n      party\ngender   Democrat Independent Republican\n     F  4.5020535   0.6994517 -5.3159455\n     M -4.5020535  -0.6994517  5.3159455\n\n\nKoska testin p-arvo on pieni, niin nollahypoteesi hylätään ja todetaan, että puoluekannatus riippuu tilastollisesti merkitsevästi sukupuolesta. Testin luotettavuuden kannalta on kuitenkin hyvä huomioida, että testiin liittyy oletuksia, jotka koskevat odotettuja frekvenssejä (eli nollahypoteesin mukaisen ristiintaulukon frekvenssejä). Tyypillisesti vaaditaan, että odotetun frekvenssin on oltava vähintään 5 vähintään 80%:ssa taulukon soluista, eikä yhdenkään solun odotettu frekvenssi ole alle 1. Tarkistetaan oletukset edellisen esimerkin tapauksessa:\n\nall(Xsq$expected &gt;= 1)\n\n[1] TRUE\n\nmean(Xsq$expected &gt;= 5) &gt;= 0.80\n\n[1] TRUE\n\n\nOletukset ovat tältä osin kunnossa. Edellä funktio all ottaa syötteenään loogisen vektorin ja palauttaa TRUE jos syötteen kaikki alkiot ovat TRUE. Muutoin funktio palauttaa FALSE.\nEdellisessä esimerkissä ristiintaulukko oli valmiiksi rakennettu annetuista frekvensseistä. Ristiintaulukko voitaisiin myös rakentaa yksilötason aineistosta, esimerkiksi datakehikosta, joka sisältää rivin jokaista kyselyyn vastannutta henkilöä kohden ja tiedon vastaajan ilmoittamasta puolueesta ja sukupuolesta. Seuraavassa esimerkissä kyselytutkimusaineisto on muuttujassa poll_data, joka voidaan muuntaa ristiintauloksi funktiolla table. Huomataan, että tällä tavalla muodostettu ristiintaulukko on sama kuin suoraan frekvensseistä koottu taulukko.\n\nhead(poll_data)\n\n  gender    party\n1      F Democrat\n2      F Democrat\n3      F Democrat\n4      F Democrat\n5      F Democrat\n6      F Democrat\n\nnrow(poll_data)\n\n[1] 2757\n\n# The cross tabulations are the same\nidentical(M, table(poll_data))\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html#varianssianalyysi",
    "href": "09-statistical_tests.html#varianssianalyysi",
    "title": "9  Tilastollinen testaaminen",
    "section": "9.4 Varianssianalyysi",
    "text": "9.4 Varianssianalyysi\nVarianssianalyysin voidaan ajatella olevan \\(t\\)-testin yleistys, jossa yhden tai kahden odotusarvon sijaan verrataankin kerralla useamman ryhmän odotusarvoja keskenään. Menetelmä saa nimensä siitä, että sen testisuure perustuu kiinnostuksen kohteena olevan muuttujan kokonaisvaihtelun (varianssin) jakamiseen verratavien ryhmien sisäiseen vaihteluun ja niiden väliseen vaihteluun. Koska harjoitusaineistossa study_data ei vielä ole kategorista muuttujaa, jossa on vähintään kolme kategoriaa, niin luodaan sellainen.\n\nstudy_data &lt;- read.table(\"data/study_data.txt\")\n\n# create a new categorical variable called age_group\n# 3,5,6 =&gt; ryhmä 1\n# 2,4,8 =&gt; ryhmä 2\n# 1,7   =&gt; ryhmä 3\n# vaste: weight\nstudy_data$age_group &lt;- c(\"3\", \"2\", \"1\", \"2\", \"1\", \"1\", \"3\", \"2\")\nstudy_data$fage_group &lt;- factor(study_data$age_group)\n\nHypoteesit ovat:\n\n\\(H_0\\): Ryhmien odotusarvot ovat samat tarkasteltavan muuttujan suhteen (\\(\\mu_1 = \\mu_2 = \\dots = \\mu_n\\)),\n\\(H_1\\): Ryhmien odotusarvoissa on eroa tarkasteltavan muuttujan suhteen (\\(\\mu_i \\ne \\mu_j\\) ainakin joillekin \\(i \\ne j\\)).\n\n\n# conduct Analysis of Variance (ANOVA) for study_data\n# we test if averages of height differ between age groups\nsummary(aov(height ~ fage_group, data = study_data))\n\n            Df Sum Sq Mean Sq F value Pr(&gt;F)\nfage_group   2   5599    2799   0.782  0.506\nResiduals    5  17901    3580               \n\n\nVarianssianalyysin summary sisältää seuraavat sarakkeet: Df kertoo testiin liittyvän \\(F\\)-jakauman vapausasteet, Sum Sq kertoo ryhmiin liittyvän neliösumman ja jäännösneliösumman, Mean Sq kertoo vastaavan keskineliösumman, F value kertoo testisuureen arvon ja Pr(&gt;F) kertoo testin P-arvon. Tässä tapauksessa testin p-arvo on \\(0.417\\), joten nollahypoteesia ei hylätä.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html#levenen-testi",
    "href": "09-statistical_tests.html#levenen-testi",
    "title": "9  Tilastollinen testaaminen",
    "section": "9.5 Levenen testi",
    "text": "9.5 Levenen testi\nLevenen testillä tutkitaan ovatko jonkin muuttujan varianssit samat kahdessa tai useammassa ryhmässä. Testiä ei ole toteutettu valmiiksi R:ssä, mutta se on saatavilla Rcourse-paketin kautta funktiossa leveneTest. Testin nollahypoteesi on, että muuttujan varianssit ovat samat joka ryhmässä.\nSelvitetään onko harjoitusaineiston study_data muuttujan height varianssissa eroa eri ikäryhmien välillä (fage_group) Levenen testillä.\n\nleveneTest(height ~ fage_group, data = study_data)\n\nLevene's Test for Homogeneity of Variance (center = median)\n      Df F value Pr(&gt;F)\ngroup  2  0.7627 0.5139\n       5               \n\n\nTestin p-arvo löytyy sarakkeesta Pr(&gt;F), ja se on \\(0.6105\\). Testin mukaan muuttujan varianssit ovat siis samat joka ryhmässä, ja nollahypoteesi jää voimaan.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "09-statistical_tests.html#shapiro-wilk--testi",
    "href": "09-statistical_tests.html#shapiro-wilk--testi",
    "title": "9  Tilastollinen testaaminen",
    "section": "9.6 Shapiro-Wilk -testi",
    "text": "9.6 Shapiro-Wilk -testi\nShapiro-Wilk -testillä tutkitaan onko jokin muuttuja normaalijakautunut. Testi löytyy funktiosta shapiro.test, ja se ottaa argumenttinaan yhden muuttujan havainnot vektorina. Funktiolla ei voi siis suoraan testata esimerkiksi sitä, onko muuttuja normaalijakautunut joissakin osaryhmissä, vaan aineisto on ensin jaettava sopiviin osiin. Testin nollahypoteesi on, että muuttuja on normaalijakautunut.\nTarkastellaan jälleen harjoitusaineistoa study_data ja testataan muuttujan height normaalisuutta.\n\nshapiro.test(study_data$height)\n\n\n    Shapiro-Wilk normality test\n\ndata:  study_data$height\nW = 0.52834, p-value = 2.26e-05\n\n\nTestin p-arvon voi lukea kohdasta p-value ja se on aineistolle \\(0.8973\\), eli height-muuttuja on testin mukaan normaalijakautunut, ja nollahypoteesi jää voimaan.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tilastollinen testaaminen</span>"
    ]
  },
  {
    "objectID": "10-modelling.html",
    "href": "10-modelling.html",
    "title": "10  Lineaariset mallit",
    "section": "",
    "text": "10.1 Teoria\nYksinkertaisin mahdollinen lineaarinen regressiomalli on:\n\\[\n  y = \\beta_0 + \\beta_1 x_1 + \\epsilon\n\\]\nMallissa siis oletetaan, että auton pysähtymismatka nopeudella 0 km/h on \\(\\beta_0\\) ja kasvaa \\(\\beta_1\\) verran, kun nopeus kasvaa 1 km/h. Lisäksi mukana on virhetermi \\(\\epsilon\\), joka selittää satunnaisen vaihtelun tuloksissa lineaarisen käyrän ympärillä.\nJos malliin halutaan lisätä selittäviä muuttujia, kuten auton jarrujen kunto (\\(x_2\\)) tai sääolosuhteet (\\(x_3\\)), malli näyttää tältä:\n\\[\n  y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 + \\ldots + \\epsilon\n\\]\nEli jokaiselle selittävälle muuttujalle annetaan oma regressiokerroin.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "10-modelling.html#teoria",
    "href": "10-modelling.html#teoria",
    "title": "10  Lineaariset mallit",
    "section": "",
    "text": "\\(y\\) on vastemuuttuja, eli tässä auton pysähtymismatka\n\\(\\beta_0\\) on ns. vakiotermi eli regressiosuoran \\(y\\)-akselin leikkauskohta\n\\(\\beta_1\\) on selittävän muuttujan eli auton nopeuden regressiokerroin eli regressiosuoran kulmakerroin\n\\(x_1\\) on selittävä muuttuja eli auton nopeus\n\\(\\epsilon\\) on residuaali (jäännösvirhe), joka oletetaan normaalijakautuneeksi",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "10-modelling.html#esimerkki",
    "href": "10-modelling.html#esimerkki",
    "title": "10  Lineaariset mallit",
    "section": "10.2 Esimerkki",
    "text": "10.2 Esimerkki\nMuutetaan ensin cars-aineiston muuttujat meille tuttuihin yksiköihin, ja piirretään hajontakuvio havainnoista:\n\n# Change to SI units\ncars$speed &lt;- cars$speed * 1.60934\ncars$dist &lt;- cars$dist * 0.0254\n# Scatter plot\nplot(\n  cars$speed, \n  cars$dist,\n  xlab = \"Speed (km/h)\", \n  ylab = \"Distance (m)\",\n  main = \"Stopping distances of cars\"\n)\n\n\n\n\n\n\n\n\nAutojen välillä on eroja, mutta kuten voi odottaa, suuremmilla nopeuksilla auton pysähtymismatka kasvaa. Käytetään seuraavaksi R:n funktiota lm, jolla voidaan sovittaa dataan lineaarinen malli:\n\nmodel &lt;- lm(dist ~ speed, data = cars)\n\nlm-funktiolle annetaan ensimmäiseksi argumentiksi lineaarisen mallin kaava, jossa ~ korvaa yllä nähdyn yhtäkuin-merkin. HUOM: vakiotermi on automaattisesti mukana, eli sitä ei tarvitse kirjata erikseen. Lisäksi täytyy antaa argumentti data, jonka tulee olla datakehikko, josta kaavassa olevat muuttujat löytyvät.\nLineaarisesta mallista saadaan irti paljon tietoa, tärkeimpinä mallin regressiokertoimet (coefficients), jotka saadaan näkyviin funktiolla coef, jolle annetaan argumenttina lineaarisen mallin sisältävä objekti model.\n\ncoef(model)\n\n(Intercept)       speed \n-0.44650901  0.06206469 \n\n\nYllä olevista kertoimista voidaan päätellä, että kun auton nopeus kasvaa 1 km/h niin sen pysähtymismatka kasvaa keskimäärin noin 0.06 m, ja odotettu kasvukäyrä leikkaa \\(y\\)-akselin -0.4 m kohdalla. Voimme piirtää tämän käyrän kuvaajaan abline-funktion avulla, antamalla sille mallin kertoimet:\n\n\ncf &lt;- coef(model)\nplot(\n  cars$speed, \n  cars$dist,\n  xlab = \"Speed (km/h)\", \n  ylab = \"Distance (m)\",\n  main = \"Stopping distances of cars\"\n)\nabline(a = cf[1], b = cf[2])",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "10-modelling.html#tarkempia-tietoja-mallista",
    "href": "10-modelling.html#tarkempia-tietoja-mallista",
    "title": "10  Lineaariset mallit",
    "section": "10.3 Tarkempia tietoja mallista",
    "text": "10.3 Tarkempia tietoja mallista\nMuihin mallin tietoihin pääsee käsiksi summary-funktion avulla, joko tulostamalla tuloksen konsoliin, tai sijoittamalla sen muuttujaan, josta voi etsiä mallin tietoja.\n\n# Print summary information\nsummary(model)\n\n\nCall:\nlm(formula = dist ~ speed, data = cars)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.73835 -0.24194 -0.05771  0.23405  1.09731 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.446509   0.171664  -2.601   0.0123 *  \nspeed        0.062065   0.006558   9.464 1.49e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3906 on 48 degrees of freedom\nMultiple R-squared:  0.6511,    Adjusted R-squared:  0.6438 \nF-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12\n\n# Save summary and access specific information\ns &lt;- summary(model)\ns$r.squared\n\n[1] 0.6510794\n\n\nsummary kertoo mm. regressiokertoimien arvojen lisäksi niihin liittyvät p-arvot kohdassa Pr(&gt;|t|), sekä mallin selitysasteen (merkintätapa johtuu siitä, että p-arvot tulevat \\(t\\)-testeistä). Tässä tapauksessa muuttujan speed p-arvo on hyvin pieni, joten voimme todeta suurella varmuudella, että autojen pysähtymismatka riippuu (lineaarisesti) auton nopeudesta. \\(R^2\\) eli R-squared kertoo, kuinka suuren osuuden pysähtymismatkojen varianssista auton nopeus selittää.\nMallin regressiokerrointen estimoitu kovarianssimatriisi saadaan funktiolla vcov (variance-covariance matrix). Kertoimien keskivirheet saadaan tästä edelleen helposti matriisin diagonaalin neliöjuurina (funktiot diag ja sqrt):\n\n# Covariance matrix of the regression coefficients\nvcov(model)\n\n             (Intercept)         speed\n(Intercept)  0.029468659 -1.065882e-03\nspeed       -0.001065882  4.300714e-05\n\n# Standard errors only\nsqrt(diag(vcov(model)))\n\n(Intercept)       speed \n0.171664380 0.006557983",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "10-modelling.html#ennustaminen",
    "href": "10-modelling.html#ennustaminen",
    "title": "10  Lineaariset mallit",
    "section": "10.4 Ennustaminen",
    "text": "10.4 Ennustaminen\nKun lineaarinen malli on estimoitu, sen perusteella voidaan myös ennustaa arvoja uusille havainnoille. Tämä tapahtuu predict-funktiolla, jolle annetaan malli, sekä datakehikko, joka sisältää ne selittäjien arvot, joille halutaan laskea ennusteet. Tämä datakehikko voi sisältää useita rivejä, jolloin ennuste lasketaan joka riville. Ennustetaan edellisen mallin perusteella pysähtymismatka autolle kolmella uudella nopeudella ja lisätään ne edelliseen kuvaajaan punaisilla rukseilla:\n\n# Create data frame with new speed values\nnew_data &lt;- data.frame(speed = c(25, 15, 38))\n# Create dist column by predicting from linear model\nnew_data$dist &lt;- predict(model, newdata = new_data)\n\n# Add points to previous plot\nplot(\n  cars$speed, \n  cars$dist,\n  xlab = \"Speed (km/h)\", \n  ylab = \"Distance (m)\",\n  main = \"Stopping distances of cars\")\nabline(a = model$coefficients[1], b = model$coefficients[2])\npoints(new_data$speed, new_data$dist, pch = 4, col = \"red\")\n\n\n\n\n\n\n\n\nKuten huomataan, ennustetut arvot ovat täsmälleen käyrän päällä.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "10-modelling.html#korrelaatio",
    "href": "10-modelling.html#korrelaatio",
    "title": "10  Lineaariset mallit",
    "section": "10.5 Korrelaatio",
    "text": "10.5 Korrelaatio\n\nKorrelaatio on lineaarisen regression ohella tapa mitata kahden muuttujan välistä riippuvuutta. Korrelaatiolle on monia erilaisia mittareita, joista yleisimmät ovat Pearsonin korrelaatiokerroin, joka mittaa kahden muuttujan välistä lineaarista riippuvuutta, ja Spearmanin järjestyskorrelaatiokerroin, joka mittaa kahden muuttujan välistä riippuvuutta ilman lineaarisuusoletusta, mutta olettaa kuitenkin monotonisen riippuvuuden. HUOM: korrelaatio ei ota kantaa siihen, kuinka vahva riippuvuus on (käyrän jyrkkyys), vaan pelkästään siihen, kuinka systemaattinen riippuvuus on. Kummatkin korrelaatiokertoimet saavat arvoja väliltä [-1, 1], jossa -1 on täydellinen negatiivinen korrelaatio (toisen muuttujan kasvaessa toinen aina pienenee) ja 1 on täydellinen positiivinen korrelaatio.\nKorrelaation kahden vektorin välillä voi R:ssä laskea funktiolla cor. Otetaan esimerkiksi R:n sisäinen aineisto Indometh, jossa on mitattu indometasiinin farmakokinetiikkaa, ja selvitetään ajan ja indometasiinin konsentraation väliselle riippuvuudelle Pearsonin ja Spearmanin korrelaatiokertoimet. Piirretään sen jälkeen hajontakuvio mittaustuloksista ja lisätään kuvaajaan alaotsikoksi korrelaatiokertoimet. Tutustumme samalla funktioon round, jolla voi pyöristää lukuja halutulle desimaalitarkkuudelle. Huomaa, että round-funktio pyöristää aina lähimpään parilliseen lukuun, esim. luku 0.5 pyöristyy lukuun 0, mutta 1.5 pyöristyy lukuun 2. Funktio mtext lisää tekstin kuvaajan marginaaliin.\n\n# Pearson correlation\npearson &lt;- cor(Indometh$time, Indometh$conc, method = \"pearson\")\n# Spearman correlation\nspearman &lt;- cor(Indometh$time, Indometh$conc, method = \"spearman\")\n# Scatter plot\nplot(\n  Indometh$time, \n  Indometh$conc,\n  xlab = \"Time\", \n  ylab = \"Concetration\",\n  main = \"Pharmacokinetics of indometacin\"\n)\n\n# Paste concatenates strings\nsubtitle &lt;- paste(\n  \"Pearson correlation:\", round(pearson, digits = 2),\n  \"Spearman correlation:\", round(spearman, digits = 2)\n)\n# Add subtitle to plot\nmtext(subtitle)\n\n\n\n\n\n\n\n\nTässä esimerkissä nähdään hyvin Pearsonin ja Spearmanin korrelaatiokertoimien ero. Koska Indometasiinin konsentraatio laskee eksponentiaalisesti, ei lineaarisesti, Pearsonin korrelaatiokerroin on “vain” -0.7, kun taas Spearmanin korrelaatiokerroin -0.97 vastaa lähes täydellistä negatiivista korrelaatiota.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Lineaariset mallit</span>"
    ]
  },
  {
    "objectID": "11-functions.html",
    "href": "11-functions.html",
    "title": "11  Funktiot",
    "section": "",
    "text": "11.1 Funktion käsite\nFunktio on nimetty kokonaisuus järjesteltyä ja uudelleenkäytettävää koodia, jonka tarkoitus on suorittaa yksi tarkkaan määrätty tehtävä. Funktioilla on syöte (input) ja tulos (output). Funktion tehtävä on palauttaa (return) syötteen perusteella laskettu tulos. Alla olevassa kuvassa näkyvät funktion neljä osaa: nimi, syöte, toiminnallisuus ja tulos.\nOtetaan esimerkiksi kaksi funktiota: “Keskiarvo” ottaa syötteenä halutun määrän lukuja, ja laskee niiden keskiarvon. “Vastinjuoste” ottaa syötteenä DNA-juosteen ja palauttaa sen vastinjuosteen.\nFunktioilla voi olla myös erityyppisiä syötteitä. Voitaisiin esimerkiksi määritellä funktio, jolle annettaisiin syötteenä henkilön ikä, pituus, paino, sekä elintapatietoja, ja funktio laskisi näiden pohjalta eliniänodotteen. Yksittäisestä funktion syötteestä käytetään tavallisesti nimitystä “argumentti”.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Funktiot</span>"
    ]
  },
  {
    "objectID": "11-functions.html#r-funktiot",
    "href": "11-functions.html#r-funktiot",
    "title": "11  Funktiot",
    "section": "11.2 R-funktiot",
    "text": "11.2 R-funktiot\n\n11.2.1 Funktioiden määrittely\nTähän mennessä olemme jo käyttäneet monia R-funktioita, eikä meidän ole tarvinnut miettiä niiden toimintaa kovin syvällisesti. Mahdolliset virhetilanteet on kuitenkin paljon helpompi ratkaista, kun ymmärtää miten funktiot toimivat R:ssä.\nR-funktioita luodaan function-komennolla. Funktion luominen näyttää tältä:\n\nR-funktiot siis koostuvat samoista osista kuin yllä esitellyt funktiot:\n\nFunktion nimi nimeää muuttujan, johon funktio tallennetaan.\nFunktion syöte koostuu argumenteista (funktio voi olla myös argumentiton).\nFunktion toiminnallisuus on R-koodia.\nFunktion tulos palautetaan komennolla return.\n\nTehdään esimerkiksi funktio BMI:n laskemiseen:\n\n# Define function name and arguments\nbmi &lt;- function(height, mass) {\n  # Compute BMI\n  value &lt;- mass / height^2\n  rounded &lt;- round(value, digits = 1)\n  # Return computed value\n  return(rounded)\n}\n\nEnsimmäisellä rivillä määritellään muuttuja, johon funktio tallennetaan, eli funktion nimi bmi. Lisäksi määritetään funktion argumentit, tässä tapauksessa height ja mass. Itse funktion koodi tulee aaltosulkeiden sisään seuraaville riveille. Ensimmäinen koodirivi laskee BMI:n ja toinen pyöristää tuloksen yhden desimaalin tarkkuuteen. Kolmas rivi palauttaa sen.\nVoimme nyt kutsua (call) funktiotamme aivan kuin muitakin R-funktioita:\n\n# Example\nmy_bmi &lt;- bmi(height = 1.79, mass = 74)\nmy_bmi\n\n[1] 23.1\n\n\nHUOM: palautettava arvo on ainoa asia, joka välittyy funktion ulkopuolelle. Koska funktiomme palauttaa pyöristetyn arvon, alkuperäiseen arvoon ei pääse funktion ulkopuolelta käsiksi.\n\nmy_bmi &lt;- bmi(height = 1.90, mass = 95)\n# Throws error\nvalue\n\nFunktioiden sisällä luodut muuttujat ovat siis olemassa vain sen sisällä ja lakkaavat olemasta, kun funktion suoritus lakkaa.\n\n\n11.2.2 Argumentit ja funktion kutsuminen\nR:ssä funktioiden argumentteja voi määritellä eri tavoilla, mutta yleisimmässä tapauksessa funktiolla on tietty määrä nimettyjä argumentteja. Edellisen esimerkin bmi-funktiolla on kaksi argumenttia, height ja mass. R-kunktioita voi kutsua monella eri tavalla, ja tutustutaan tähän lisää tämän yksinkertaisen funktion avulla.\nYksi tapa on kutsua funktiota antamalla argumenttien arvot ilman niiden nimiä. HUOM: jos argumentteja ei nimeä, niiden tulee olla oikeassa järjestyksessä. Alla olevan esimerkin toisessa kohdassa argumentit menevät sekaisin.\n\n# Call without argument names\nbmi(1.65, 62)\n\n[1] 22.8\n\n# Arguments in wrong order -&gt; weird results / error\nbmi(62, 1.65)\n\n[1] 0\n\n\nArgumentit voi myös nimetä, kuten edellisissä esimerkeissä tehtiin. Tällöin järjestyksellä ei ole väliä, koska funktiolle on selvää, mitä argumenttia tarkoitetaan.\n\nbmi(height = 1.65, mass = 62)\n\n[1] 22.8\n\nbmi(mass = 62, height = 1.65)\n\n[1] 22.8\n\n\nOn myös mahdollista nimetä vain osa argumenteista. Tällöin nimeämättömät argumentit asetetaan argumenteiksi “tyhjiin kohtiin” vasemmalta oikealle.\n\nbmi(1.65, mass = 62)\n\n[1] 22.8\n\nbmi(62, height = 1.65)\n\n[1] 22.8\n\n\nJos funktioille yritetään antaa argumentteja, joita ei ole määritelty, seuraa virhe:\n\n# Causes error\nbmi(height = 1.65, weight = 62)\n\nError in bmi(height = 1.65, weight = 62): unused argument (weight = 62)\n\n\nSamoin jos jokin argumentti puuttuu, seuraa virhe:\n\n# Causes error\nbmi(height = 1.65)\n\nError in bmi(height = 1.65): argument \"mass\" is missing, with no default\n\n\nHUOM: vaikka argumentit saa antaa haluamassaan järjestyksessä ja nimettynä tai nimeämättömänä, kannattaa kuitenkin olla johdonmukainen. Yleisohjeena argumentit kannattaa aina nimetä ja pyrkiä antamaan siinä järjestyksessä, kuin ne on funktiossa määritelty. Näin koodin lukeminen ja ylläpito on paljon helpompaa. Poikkeuksena sääntöön ovat funktiot, joiden toiminta on yksinkertaista, tai joiden ensimmäiset argumentit ovat niin tunnettuja, että niitä ei ole syytä nimetä.\nOtetaan esimerkiksi funktio seq. Jos avaat funktion help-sivun komennolla ?seq, näet, että ensimmäiset argumentit ovat nimeltään from ja to. Koska seq on hyvin yleinen ja tunnettu, sitä kutsutaan yleensä niin, että from ja to jätetään nimeämättä. Muut argumentit, kuten by ja length.out yleensä nimetään, koska niitä ei aina käytetä, eikä voida olettaa koodin lukijan muistavan, mitä argumenttia tarkoitetaan, vaikka seq toimisi ilman nimiä, jos annettaisiin peräkkäin from, to ja by. Vastaavasti plot-komennon tapauksessa ei aina kirjoiteta nimiä x ja y-argumenteille, mutta väriä yms. ohjaavat argumentit nimetään.\n\n11.2.2.1 Oletusarvot (default values)\nMonilla R-funktioilla on paljon argumentteja, joista kaikkia ei kuitenkaan tarvitse määrittää erikseen, vaan niillä on oletusarvoja (default values). Esimerkiksi seq tekee oletuksena vektorin, joka sisältää kaikki kokonaisluvut from-argumentista to-argumenttiin. Tätä käyttäytymistä voi kuitenkin muuttaa by- ja length.out-argumentteja säätämällä.\nTehdään nyt omaan bmi-funktioomme uusi argumentti height_multiplier, joka saa oletuksena arvon 1. Jos halutaan antaa pituus senttimetreissä metrien sijaan, voidaan asettaa pituuden kertoimeksi 0.01.\n\nbmi &lt;- function(height, mass, height_multiplier = 1) {\n  # Compute BMI\n  value &lt;- mass / (height * height_multiplier)^2\n  rounded &lt;- round(value, digits = 1)\n  # Return computed value\n  return(rounded)\n}\nbmi(height = 1.65, mass = 62)\n\n[1] 22.8\n\nbmi(height = 165, mass = 62, height_multiplier = 0.01)\n\n[1] 22.8\n\n\n\n\nArgumentin oletusarvo merkataan siis funktion määrittelyssä =-merkillä, kuten funktion argumenttien anto yleensä. Monilla valmiiden funktioiden argumenteilla on oletusarvona tyhjä arvo eli NULL. Tämä tarkoittaa usein, että argumentin voi jättää tyhjäksi, mutta oletusarvon valinta on niin monimutkainen prosessi, että sitä ei voi kirjoittaa funktion määrittelyssä yhdelle riville. Usein tämä tarkoittaa sitä, että oletusarvo riippuu muista argumenteista. HUOM: NULL on eri asia kuin NA, ja käyttäytyy eri tavoin. Aiheesta lisää täällä.\n\n\n\n11.2.3 Funktio ilman argumentteja\nJoillain funktioilla ei ole ollenkaan argumentteja. Esimerkiksi R:n sisäiset funktiot Sys.time ja Sys.Date palauttavat tämänhetkisen ajan ja päivämäärän, eivätkä tarvitse argumentteja.\n\nSys.time()\n\n[1] \"2024-06-18 16:13:39 EEST\"\n\n\nItse tehdyt funktiot voivat myös toimia ilman argumentteja. Niitä käytetään usein R-istunnon tilan, koodia ajavan tietokoneen ominaisuuksien tai ajan selvittämiseen. Tämä melko hyödytön esimerkkifunktio palauttaa tämän dokumentin kirjoittajan nimen:\n\nauthor &lt;- function() {\n  return(\"Anton Klåvus\")\n}\nauthor()\n\n[1] \"Anton Klåvus\"\n\n\n\n\n11.2.4 Palautus (return)\nTutkitaan return-käskyä, eli palautusta R-funktiosta hieman tarkemmin.\n\n\n11.2.5 Usean arvon palautus\n\n\nR-funktiot palauttavat aina yhden objektin. Palautukseen käytetään funktiota return, kuten aiemmin on nähty. Jos funktiosta halutaan ulos useampi objekti, on muodostettava esimerkiksi lista, joka sisältää halutut objektit. Jos siis bmi-funktiosta haluttaisiin palauttaa sekä pyöristetty, että alkuperäinen BMI:n arvo, voidaan ne palauttaa listassa:\n\nbmi_list &lt;- function(height, mass, height_multiplier = 1) {\n  # Compute BMI\n  value &lt;- mass / (height * height_multiplier)^2\n  rounded &lt;- round(value, digits = 1)\n  # Return computed value\n  values &lt;- list(original = value,\n                 rounded = rounded)\n  return(values)\n}\nresult &lt;- bmi_list(1.65, 62)\nresult\n\n$original\n[1] 22.77319\n\n$rounded\n[1] 22.8\n\nresult$rounded\n\n[1] 22.8\n\n\n\n\n11.2.6 Palautus ilman return-käskyä\nR on siitä erikoinen ohjelmointikieli, että R-funktiot voivat palauttaa arvoja myös ilman eksplisiittistä return-käskyä. Jos R-funktiossa ei ole return-käskyä, ja viimeinen rivi on vain muuttuja, tai sijoitus muuttujaan, tämän muuttujan arvo palautetaan automaattisesti. bmi-funktion voisi siis kirjoittaa myös näin:\n\nbmi &lt;- function(height, mass, height_multiplier = 1) {\n  # Compute BMI\n  value &lt;- mass / (height * height_multiplier)^2\n  rounded &lt;- round(value, digits = 1)\n  # Return computed value\n  rounded\n}\nbmi(1.65, 62)\n\n[1] 22.8\n\n\nAlussa on kuitenkin hyvä käyttää return-käskyä, niin pysyy paremmin perässä siitä, mitä koodi tekee, eikä sen kirjoittaminen ole kokeneellekaan ohjelmoijalle huono tapa.\n\n\n11.2.7 Funktio ilman tulosta\nFunktion tarkoitus ei ole aina palauttaa jotain. Yleisiä esimerkkejä ovat cat ja plot, jotka tulostavat ja piirtävät asioita. Jos näiden funktion paluuarvon yrittää sijoittaa muuttujaan, on tuloksena NULL, eli tyhjä arvo.\n\ncat_return &lt;- cat(\"What does cat return?\\n\")\n\nWhat does cat return?\n\ncat_return\n\nNULL\n\n\nItse tehty funktio palauttaa NULL, jos viimeinen komento palauttaa NULL:\n\n# Function for plotting blue squares\nblue_squares &lt;- function(x, y) {\n  plot(x, y, pch = 3, col = \"blue\")\n}\nvalue &lt;- blue_squares(1:5, c(2, 5, 3, 3, 8))\n\n\n\n\n\n\n\nvalue\n\nNULL\n\n\n\n\n11.2.8 Funktion lyhytmuoto\nYksinkertaisten (tyypillisesti yhden rivin) funktioiden tapauksessa aaltosulkuja ei ole pakollista käyttää funktion koodin rajaamiseen. Tarkastellaan esimerkkifunktiota, joka laskee puuttuvien havaintojen NA määrän vektorista x.\n\ncount_missing &lt;- function(x) {\n  mis &lt;- is.na(x)\n  count &lt;- sum(mis)\n  return(count)\n}\n\nPurkamalla välivaiheet auki ja jättämällä return-käsky pois, voitaisiin funktio kirjoittaa lyhytmuodossa seuraavasti:\n\ncount_missing &lt;- function(x) sum(is.na(x))\n\n\n\n11.2.9 Anonyymi funktio\nJos funktiota tarvitaan vain yksittäiseen laskutoimitukseen, voidaan se määritellä myös ilman muuttujaa, johon funktio tallennettaisiin. Tällöin kyse on ns. anonyymistä funktiosta (inline function, anonymous function, lambda function). Anonyymi funktio määritellään kirjoittamalla \\(x) jonka perään kirjoitetaan funktion lauseke, esim. funktio joka laskee vektorin x neliöt voitaisiin kirjoittaa muodossa\n\n\\(x) x^2\n\nja sitä voidaan käyttää kuten muitakin funktioita\n\n(\\(x) x^2)(3)\n\n[1] 9\n\ncurve((\\(x) x^2)(x))\n\n\n\n\n\n\n\n\nAnonyymeillä funktioilla voi myös olla useampi argumentti\n\n(\\(x, y) x + y)(3, 4)\n\n[1] 7\n\n\nHuom! Anonyymit funktiot vaativat R-version 4.1 tai sitä uudemman.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Funktiot</span>"
    ]
  },
  {
    "objectID": "12-control_flow.html",
    "href": "12-control_flow.html",
    "title": "12  Ehtorakenteet",
    "section": "",
    "text": "12.1 Loogiset operaattorit\nTässä on lyhyt lista loogisista operaattoreista R:ssä\nKaikki loogiset operaattorit palauttavat joko arvon (tai vektorin arvoja) TRUE, FALSE tai NA. Vertailuoperaattorien käyttö on jo tullut tutuksi aikaisemmissa kappaleissa, mutta tutustutaan vielä tarkemmin viimeisten rivien operaattoreihin.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Ehtorakenteet</span>"
    ]
  },
  {
    "objectID": "12-control_flow.html#sec-logical-operators",
    "href": "12-control_flow.html#sec-logical-operators",
    "title": "12  Ehtorakenteet",
    "section": "",
    "text": "Operaattori\nToiminto\n\n\n\n\n&lt;\npienempi kuin\n\n\n&lt;=\npienempi tai yhtä suuri kuin\n\n\n&gt;\nsuurempi kuin\n\n\n&gt;=\nsuurempi tai yhtä suuri kuin\n\n\n==\nyhtä kuin\n\n\n!=\nei yhtä kuin\n\n\n!\nei (negaatio)\n\n\n|\nlooginen “tai” alkioittain\n\n\n||\nlooginen “tai” yksittäisille arvoille\n\n\n&\nlooginen “ja” alkioittain\n\n\n&&\nlooginen “ja” yksittäisille arvoille\n\n\n%in%\nmitkä vasemman puolen alkiot ovat myös oikean puolen alkioita?\n\n\n\n\n\n\n\n12.1.0.1 Negaatio\nLooginen negaatio palauttaa loogisen lauseen vastakohdan, eli muuttaa arvon TRUE arvoksi FALSE ja arvon FALSE arvoksi TRUE.\n\n10 &gt; 12\n\n[1] FALSE\n\n!(10 &gt; 12)\n\n[1] TRUE\n\n# Also works without parentheses\n!10 &gt; 12\n\n[1] TRUE\n\n!is.na(NA)\n\n[1] FALSE\n\n\n\n\n12.1.0.2 Looginen “tai” (disjunktio)\nLoogiselle tai-operaattorille annetaan kaksi loogista lausetta, ja tai-operaattori palauttaa TRUE, jos vähintään toinen lauseista on TRUE. R:ssä tai-operaattori merkitään pystyviivalla | tai kahdella pystyviivalla ||. Näistä | käy läpi vektoreita alkioittain, || vertaa kahta loogista lausetta, ja toista lausetta ei suoriteta, jos ensimmäinen on TRUE (koska || palauttaa TRUE riippumatta toisen lauseen arvosta). Jos tämä tuntui monimutkaiselta, niin riittää muistaa, että ehtorakenteissa kannattaa käyttää muotoa ||.\n\n10 &gt; 12 || \"a\" &lt; \"b\"\n\n[1] TRUE\n\n2 &gt; 1 || 4 &gt; 2\n\n[1] TRUE\n\n\"a\" &gt; \"c\" || 1 &gt; 10\n\n[1] FALSE\n\n\n\n\n12.1.0.3 Looginen “ja” (konjunktio)\nLoogiselle ja-operaattorille annetaan kaksi lausetta. Ja-operaattori palauttaa TRUE, jos kummatkin lauseet ovat TRUE. R:ssä ja-operaattorit ovat & ja &&, jotka käyttäytyvät kuten | ja ||.\n\n10 &gt; 12 && \"a\" &lt; \"b\"\n\n[1] FALSE\n\n2 &gt; 1 && 4 &gt; 2\n\n[1] TRUE\n\n\"a\" &gt; \"c\" && 1 &gt; 10\n\n[1] FALSE\n\n\n\n\n12.1.0.4 Osajoukko\n%in%-operaattorilla voi tarkistaa, kuulvatko jotkin arvot johonkin toiseen joukkoon arvoja. Tämä voitaisiin toteuttaa myös usealla tai-operaattorilla, mutta %in% on usein paljon kätevämpi.\n\ndna_bases &lt;- c(\"A\", \"C\", \"G\", \"T\")\nrna_bases &lt;- c(\"A\", \"C\", \"G\", \"U\")\n\n\"T\" %in% dna_bases\n\n[1] TRUE\n\n\"T\" %in% rna_bases\n\n[1] FALSE\n\n# With negation\n!\"A\" %in% dna_bases\n\n[1] FALSE\n\n\nOperaattoria voi soveltaa myös vektoreihin, jolloin operaattori palauttaa loogisen vektorin, jonka jokainen alkio kertoo, kuuluiko vastaava operaation vasemman puolen alkio operaation oikeaan puoleen.\n\ndna_bases %in% rna_bases\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\n\n\n12.1.0.5 Monimutkaisemmat lauseet\nOperaattoreita voidaan myös yhdistellä monimutkaisemmiksi lauseiksi. Tällöin lauseiden evaluointijärjestys määritetään tarvittaessa suluilla.\n\ndog &lt;- list(\n  breed = \"golden retriever\",\n  height = 45,\n  weight = 27\n)\n\ndog$breed == \"golden retriever\" && dog$weight &lt; 25 || dog$height &lt; 50\n\n[1] TRUE\n\n\n\n\n12.1.0.6 a &lt; x &lt; b\nusein tulee vastaan tilanteita, joissa halutaan tarkistaa, onko jokin luku halutulla välillä. Tämä kirjoitetaan matemaatiisesti esim. näin: \\(a &lt; x &lt; b\\), jossa tarkastetaan, onko \\(x\\) välillä \\((a, b)\\). Tämä ei kuitenkaan valitettavasti toimi R:ssä, vaan tarkistus pitää jakaa kahteen osaan:\n\n# Are x and y between 0 and 1?\nx &lt;- 3\ny &lt;- 0.3\n0 &lt;= x && x &lt;= 1\n\n[1] FALSE\n\n0 &lt;= y && y &lt;= 1\n\n[1] TRUE",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Ehtorakenteet</span>"
    ]
  },
  {
    "objectID": "12-control_flow.html#ehtorakenteet",
    "href": "12-control_flow.html#ehtorakenteet",
    "title": "12  Ehtorakenteet",
    "section": "12.2 Ehtorakenteet",
    "text": "12.2 Ehtorakenteet\nAloitetaan esimerkistä: tehtävänä on kirjoittaa funktio, jolle annetaan syötteenä potilaan hemoglobiiniarvo. Funktion on tarkoitus hälyttää, jos hemoglobiini laskee alle viitearvojen alarajan 117. Kyseinen funktio voisi näyttää vaikka tältä:\n\nhb_alert &lt;- function(hb) {\n  if (hb &lt; 117) {\n    return(\"Hemoglobin is low!\")\n  }\n}\n\nFunktiolla on siis yksi argumentti, hb eli hemoglobiiniarvo. Funktion sisällä on if-rakenne. Rakenteessa on kaksi osaa: ehto, ja rakenteen sisäinen koodi. Rakenteen sisäinen koodi ajetaan vain, jos ehto täyttyy. Ehto merkitään if-komennon jälkeen sulkeisiin, ja rakenteen sisäinen koodi kirjoitetaan sulkeiden jälkeen aaltosulkeiden sisään. (Jos aaltosulkeiden sisään tulisi vain yksi rivi koodia, aaltoasulkeet voi jättää pois, mutta näissä esimerkeissä käytetään aina aaltoasulkeita).\nKokeillaan, miten funktio toimii eri hemoglobiiniarvoilla:\n\n# Nothing happens\nhb_alert(130)\n# returns alert\nhb_alert(110)\n\n[1] \"Hemoglobin is low!\"\n\n\nFunktio siis toimii oletetusti, eli se hälyttää vain, jos hemoglobiinitaso on alle 117. Käyttäjän kannalta olisi kuitenkin kätevää saada jonkinlainen palaute myös silloin, kun hemoglobiinitaso on tarpeeksi korkea. Tätä varten voidaan käyttää else-komentoa:\n\nhb_alert &lt;- function(hb) {\n  if (hb &lt; 117) {\n    return(\"Hemoglobin is low!\")\n  } else {\n    return(\"Hemoglobin is OK\")\n  }\n}\n\nhb_alert(130)\n\n[1] \"Hemoglobin is OK\"\n\n\nelse-komennon jälkeinen koodi siis ajetaan, jos ehto hb &lt; 117 ei täyty.\nTällä hetkellä funktiomme toimii oikein vain naispotilaille, sillä miehillä hemoglobiiniarvojen alaraja on 134. Lisätään siis funktioomme argumentti sex sukupuolta varten ja muokataan funktion toimintaa niin, että se osaa ottaa huomioon sukupuolen. Nyt if-rakenteen ehdosta tulee jo hieman monimutkaisempi:\n\nhb_alert &lt;- function(hb, sex) {\n  if (sex == \"female\" && hb &lt; 117 || sex == \"male\" && hb &lt; 134) {\n    return(\"Hemoglobin is low!\")\n  } else {\n    return(\"Hemoglobin OK\")\n  }\n}\n\nhb_alert(hb = 120, sex = \"female\")\n\n[1] \"Hemoglobin OK\"\n\nhb_alert(hb = 120, sex = \"male\")\n\n[1] \"Hemoglobin is low!\"\n\n\nEntä jos haluaisimme tulostaa eri varoituksen mies- ja naispotilaille? Tähän tarvitaan else if-rakennetta:\n\nhb_alert &lt;- function(hb, sex) {\n  if (sex == \"female\" && hb &lt; 117) {\n    return(\"Hemoglobin is low for a female!\")\n  } else if (sex == \"male\" && hb &lt; 134) {\n    return(\"Hemoglobin is low for a male!\")\n  } else {\n    return(\"Hemoglobin OK\")\n  }\n}\n\nhb_alert(hb = 110, sex = \"female\")\n\n[1] \"Hemoglobin is low for a female!\"\n\nhb_alert(hb = 120, sex = \"male\")\n\n[1] \"Hemoglobin is low for a male!\"\n\n\nNyt funktio tarkistaa ensin, onko potilas nainen ja onko hänen hemoglobiininsa alle 117. Jos ei, siirrytään eteenpäin ja tarkistetaan, onko potilas mies ja onko hänen hemoglobiininsa alle 130. Jos ei, siirrytään viimeiseen kohtaan, ja tulostetaan “Hemoglobin is OK”.\nelse if-rakenteita voi olla rajoittamaton määrä ensimmäisen if-rakenteen jälkeen. Lisätään funktioon hälytys kriittisestä hemoglobiinin määrästä (hb &lt; 50) riippumatta sukupuolesta:\n\nhb_alert &lt;- function(hb, sex) {\n  if (sex == \"female\" && hb &lt; 117) {\n    return(\"Hemoglobin is low for a female!\")\n  } else if (sex == \"male\" && hb &lt; 134) {\n    return(\"Hemoglobin is low for a male!\")\n  } else if (hb &lt; 50) {\n    return(\"Hemoglobin is critical\")\n  } else {\n    return(\"Hemoglobin OK\")\n  }\n}\n\nhb_alert(hb = 32, sex = \"female\")\n\n[1] \"Hemoglobin is low for a female!\"\n\n\nKuten huomataan, yllä oleva koodi ei toimikaan, kuten piti. Näin alhaisella hemoglobiinilla pitäisi tulla varoitus kriittisestä tilasta. Koodi suoritus ei kuitenkaan ikinä etene kriittisen tilan varoitukseen asti, sillä ensimmäinen ehto täyttyy. Korjataan tilanne siirtämällä kriittisen tilan ehto ensimmäiseksi:\n\nhb_alert &lt;- function(hb, sex) {\n  if (hb &lt; 50) {\n    return(\"Hemoglobin is critical\")\n  } else if (sex == \"male\" && hb &lt; 134) {\n    return(\"Hemoglobin is low for a male!\")\n  } else if (sex == \"female\" && hb &lt; 117) {\n    return(\"Hemoglobin is low for a female!\")\n  } else {\n    return(\"Hemoglobin OK\")\n  }\n}\n\nhb_alert(hb = 32, sex = \"female\")\n\n[1] \"Hemoglobin is critical\"\n\nhb_alert(hb = 120, sex = \"female\")\n\n[1] \"Hemoglobin OK\"\n\nhb_alert(hb = 120, sex = \"male\")\n\n[1] \"Hemoglobin is low for a male!\"\n\n\nNyt funktio toimii haluamallamme tavalla!\nFunktioissa voi myös olla useampi ehtorakenne. Ehtorakenteita käytetään usein tarkistamaan argumenttien arvoja. Lisätään ehtorakenteet argumenttien tarkistamiseksi: \n\nhb_alert &lt;- function(hb, sex) {\n  # Hemoglobin should be numeric and positive\n  if (!is.numeric(hb) || hb &lt; 0) {\n    return(\"Hemoglobin should be numeric and positive\")\n  }\n  if (!sex %in% c(\"female\", \"male\")) {\n    return(\"This function can only deal with binary sex: female or male\")\n  }\n  \n  if (hb &lt; 50) {\n    return(\"Hemoglobin is critical\")\n  } else if (sex == \"male\" && hb &lt; 134) {\n    return(\"Hemoglobin is low for a male!\")\n  } else if (sex == \"female\" && hb &lt; 117) {\n    return(\"Hemoglobin is low for a female!\")\n  } else {\n    return(\"Hemoglobin OK\")\n  }\n}\n\nhb_alert(hb = \"120\", sex = \"female\")\n\n[1] \"Hemoglobin should be numeric and positive\"\n\nhb_alert(hb = 120, sex = \"FEMALE\")\n\n[1] \"This function can only deal with binary sex: female or male\"",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Ehtorakenteet</span>"
    ]
  },
  {
    "objectID": "12-control_flow.html#alkioiden-poimiminen-vektorista-tietyn-ehdon-perusteella",
    "href": "12-control_flow.html#alkioiden-poimiminen-vektorista-tietyn-ehdon-perusteella",
    "title": "12  Ehtorakenteet",
    "section": "12.3 Alkioiden poimiminen vektorista tietyn ehdon perusteella",
    "text": "12.3 Alkioiden poimiminen vektorista tietyn ehdon perusteella\nSeuraava tilanne on melko tyypillinen: on käytävä läpi vektorin arvot, ja säilytettävä niistä ne, jotka täyttivät tietyn ehdon. Tätä ongelmaa voi lähestyä esimerkiksi seuraavalla tavalla:\n\n\nLuo apufunktio, joka ottaa syötteeksi yhden arvon, ja tarkistaa täyttyykö ehto. Tämän funktion tulee palauttaa TRUE, jos ehto täyttyy ja FALSE, jos ehto ei täyty.\nKäytä funktiota Vectorize, jolla voit muuttaa funktiosi vektoroiduksi funktioksi. Vektorointi tarkoittaa tässä yhteydessä sitä, että yhden alkion sijaan vektoroitua funktiota voidaankin kutsua vektoriargumentilla, ja jokaiselle argumentin alkiolle suoritetaan alkuperäisen funktion määrittelemä operaatio. \nKäytä vektoroitua apufunktiota vektorin indeksointiin.\n\nTässä on esimerkki, jossa käydään läpi vektori DNA:n emäksiä, joista poimitaan vain sytosiinit ja guaniinit.\n\n# Helper function\nis_cg &lt;- function(base) {\n  if (base %in% c(\"C\", \"G\")) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\n# Vectorize\nis_cg_vector &lt;- Vectorize(is_cg)\n\n# Main function\npick_cg &lt;- function(bases) {\n  only_cg &lt;- bases[is_cg_vector(bases)]\n  return(only_cg)\n}\n\n# NOTE: this only checks the first value of the vector\nmy_bases &lt;- c(\"A\", \"C\", \"C\", \"T\", \"G\", \"T\")\n#is_cg(my_bases) # This produces error in 4.2.x\n\n# This works as expected\nis_cg_vector(my_bases)\n\n    A     C     C     T     G     T \nFALSE  TRUE  TRUE FALSE  TRUE FALSE \n\n# Pick only C and G\npick_cg(my_bases)\n\n[1] \"C\" \"C\" \"G\"",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Ehtorakenteet</span>"
    ]
  },
  {
    "objectID": "13-loops.html",
    "href": "13-loops.html",
    "title": "13  Toistorakenteet (loops)",
    "section": "",
    "text": "13.1 For-silmukka\nFor-silmukka toistaa koodia ennalta määrättyjen iteraatioiden verran. For-silmukalla voi esimerkiksi käydä läpi datakehikon tai matriisin sarakkeita tai rivejä, tai vektorin arvoja. For-silmukka iteroi aina jonkin järjestetyn rakenteen yli, esimerkiksi vektorin. For-silmukalle annetaan tyypillisesti vektori arvoja, ja ns. iteraatiomuuttuja, johon tallennetaan vuorotellen yksi alkio annetusta vektorista. Käytännössä tämä näyttää tältä:\nfor (i in seq(3, 7)) {\n  print(i)\n}\nFor-silmukassa määritetään siis ensin iteraatiomuuttuja eli i ja sen saamat arvot eli seq(3, 7) komennolla in. Sen jälkeen hakasulkeiden sisältämä koodi toistetaan jokaiselle i:n arvolle järjestyksessä. Tässä tapauksessa yksinkertaisesti tulostetaan muuttujan i arvo. Huomaa, että for-silmukan in ei ole sama asia kuin looginen operaattori %in%. in on R-kielen varattu symboli, jolloin esimerkiksi muuttuujaa nimeltä in ei ole mahdollista luoda.\nUsein halutaan käydä läpi jonkin vektorin tai matriisin arvoja. Alla oleva koodi laskee matriisin X rivien summan (tähän voisi myös käyttää valmista funktiota rowSums()). Aluksi alustetaan tyhjä vektori, johon rivien summat tallennetaan. Sen jälkeen käydään läpi matriisin rivit ja tallennetaan rivin summa alussa alustettuun vektoriin.\n# Create matrix X\nX &lt;- matrix(1:12, nrow = 4)\nX\n\n# Initialize vector for row sums\nrow_sums &lt;- rep(0, nrow(X))\n# Iterate over rows of X\nfor (i in seq(1, nrow(X))) {\n  # Assign sum of the current row to the vector\n  row_sums[i] &lt;- sum(X[i, ])\n}\n\n# Compare results with the result from base R function\nrow_sums\nrowSums(X)\nFor-silmukalla voi myös toteuttaa Ehtorakenteet-luvussa tehdyn funktion, joka poimii DNA:n emäksistä vain sytosiinit ja guaniinit. Tällä kertaa apufunktiota is_cg() ei tarvitse vektorisoida, koska for-silmukka käy läpi kaikki emäkset. Tämä silmukka voidaan toteuttaa kahdella tavalla. Ensimmäinen tapa on käyttää iteraatiomuuttujana i:tä, joka käy läpi iteraation ykkösestä emäsvektroin pituuteen:\n# Helper function\nis_cg &lt;- function(base) {\n  if (base %in% c(\"C\", \"G\")) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\n# Main function\npick_cg1 &lt;- function(bases) {\n  # Initialize empty vector\n  only_cg &lt;- c()\n  for (i in seq(1, length(bases))) {\n    # If the current base is C or G, add it to only_cg\n    if (is_cg(bases[i])) {\n      only_cg &lt;- c(only_cg, bases[i])\n    }\n  }\n  return(only_cg)\n}\n\nmy_bases &lt;- c(\"A\", \"C\", \"C\", \"T\", \"G\", \"T\")\npick_cg1(my_bases)\nToinen vaihtoehto on iteroida suoraan vektorin bases yli, jolloin iteraatiomuuttujaan tallentuu suoraan kyseinen emäs:\npick_cg2 &lt;- function(bases) {\n  # Initialize empty vector\n  only_cg &lt;- c()\n  for (base in bases) {\n    # If the current base is C or G, add it to only_cg\n    if (is_cg(base)) {\n      only_cg &lt;- c(only_cg, base)\n    }\n  }\n  return(only_cg)\n}\n\nmy_bases &lt;- c(\"A\", \"C\", \"C\", \"T\", \"G\", \"T\")\npick_cg2(my_bases)\nIteraatiomuuttujan voi siis nimetä haluamallaan tavalla, sen ei aina tarvitse olla i. Jos kuitenkin iteraatiomuuttujaan tallennetaan vain yksi luku, on suositeltavaa käyttää i:tä. Tämä on hyvin vakiintunut tapa ohjelmointikielestä ja ohjelmoijasta riippumatta, vaikka muutoin muuttujien nimeämiseen on erilaisia koulukuntia riippuen ohjelmoijan taustasta. Jos taas iteroidaan vektorin nimeltä bases yli, on luonnollinen valinta iteraatiomuuttujan nimeksi tässä tapauksessa base.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Toistorakenteet (loops)</span>"
    ]
  },
  {
    "objectID": "13-loops.html#while-silmukka",
    "href": "13-loops.html#while-silmukka",
    "title": "13  Toistorakenteet (loops)",
    "section": "13.2 While-silmukka",
    "text": "13.2 While-silmukka\n\nWhile-silmukkaa käytetään, kun iteraatioiden määrä ei ole ennalta tiedossa, vaan while-silmukkaa toistetaan niin kauan, kuin tietty ehto on voimassa. Hyvä esimerkki while-silmukasta on proteiinisynteesi (yksinkertaistettuna): alla oleva funktio käy läpi RNA-molekyylin kodoneita, kunnes löytää aloituskodonin AUG. Sen jälkeen funktio rakentaa aminohappoketjua kodonien perusteella, kunnes vastaan tulee jokin lopetuskodoneista. Oikean proteiinin löytämiseen käytetään Biostrings-paketista löytyvää geneettistä koodia, joka on nimetty vektori, jossa on kodoneita vastaavien aminohappojen kirjainlyhenne, tai lopetuskodonien tapauksessa merkki “*“:\n\nrna_code &lt;- Biostrings::RNA_GENETIC_CODE\nrna_code\n\n\nprot_synth &lt;- function(codons) {\n  # Initialize iterable as the first codon\n  i &lt;- 1\n  # Initialize empty amino acid chain\n  protein &lt;- c()\n  # Find starting codon\n  while (codons[i] != \"AUG\") {\n    i &lt;- i + 1\n  }\n  # After starting codon, build protein until one of the stop codons is met\n  while (rna_code[codons[i]] != \"*\") {\n    protein &lt;- c(protein, rna_code[codons[i]])\n    i &lt;- i + 1\n  }\n  return(protein)\n}\n\nprot_synth(\n  codons = c(\"UUG\", \"GAA\", \"AUG\", \"UGU\", \"AGU\", \"AGA\", \"UCG\", \"UCG\", \"UGA\", \"GCA\")\n)\n\nWhile-silmukalle annetaan siis ensin ehto, joka tarkistetaan ennen jokaista iteraatiota. Jos ehto täyttyy, suoritetaan yksi iteraatio, ja tarkistetaan ehto uudestaan. HUOM: while-silmukkaa koodatessa tulee huolehtia siitä, että silmukan ehdon on mahdollista olla lopulta epätosi, muuten silmukka saattaa jäädä pyörimään ikuisesti!\nKäytännössä kaikki for-silmukat voisi korvata while-silmukoilla, mutta for-silmukoiden käyttö on kätevämpää, sillä niissä iteraatiomuuttujaa ei tarvitse kasvattaa erikseen.\n\n# A simple for loop\nfor (i in seq(1, 4)) {\n  print(i * 2)\n}\n\n# The same as above\ni &lt;- 1\nwhile (i &lt;= 4) {\n  print(i * 2)\n  i &lt;- i + 1\n}",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Toistorakenteet (loops)</span>"
    ]
  },
  {
    "objectID": "13-loops.html#sisäkkäiset-silmukat-nested-loops",
    "href": "13-loops.html#sisäkkäiset-silmukat-nested-loops",
    "title": "13  Toistorakenteet (loops)",
    "section": "13.3 Sisäkkäiset silmukat (nested loops)",
    "text": "13.3 Sisäkkäiset silmukat (nested loops)\nSilmukoita voi myös olla useampi sisäkkäin. Alla olevassa esimerkissä on taulukko tutkimuksesta, jossa on mitattu eri eliöiden \\(\\beta\\)-globiinigeenin ensimmäisen eksonin samankaltaisuutta. Pienempi luku tarkoittaa enemmän samankaltaista geeniä.\n\n\n\n\n\n\nHuman\nGoat\nOpossum\nLemur\nMouse\nRabbit\nGorilla\n\n\n\n\nHuman\n0.0\n4.7\n4.6\n2.7\n3.2\n3.2\n1.6\n\n\nGoat\n4.7\n0.0\n7.2\n5.9\n7.8\n3.7\n5.5\n\n\nOpossum\n4.6\n7.2\n0.0\n5.3\n5.3\n6.3\n5.7\n\n\nLemur\n2.7\n5.9\n5.3\n0.0\n4.3\n2.7\n3.2\n\n\nMouse\n3.2\n7.8\n5.3\n4.3\n0.0\n6.0\n2.9\n\n\nRabbit\n3.2\n3.7\n6.3\n2.7\n6.0\n0.0\n3.8\n\n\nGorilla\n1.6\n5.5\n5.7\n3.2\n2.9\n3.8\n0.0\n\n\n\n\n\nTämä data on hakemiston data tiedostossa exons.csv, joten luetaan se R:ään:\n\nexons &lt;- read.csv(\"data/exons.csv\", row.names = 1)\n\nEtsitään seuravaksi kaikki eliöparit, joiden geenien etäisyys on alle 4 ja lisätään parit datakehikkoon, jossa on kaksi saraketta, ja jokainen rivi edustaa yhtä eliöparia. Käytetään tähän kahta sisäkkäistä for-silmukkaa. Toisen silmukan iteraatiomuuttujan nimi on yleensä j, seuraavan k ja niin edelleen. Käydään exons läpi niin, että i on rivin numero, ja j sarakkeen numero, ja etsitään sopivat parit.\n\n# Initialize empty data frame for the pairs\nclose_pairs &lt;- data.frame()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  for (j in seq(1, ncol(exons))) {\n    # Check if dissimilarity is below 4\n    if (exons[i, j] &lt; 4) {\n      # Add the pair as a new row to close_pairs\n      new_row &lt;- data.frame(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      close_pairs &lt;- rbind(\n        close_pairs,\n        new_row\n      )\n    }\n  }\n}\n\nclose_pairs\n\nKoodimme toimii jo ihan hyvin, mutta tuloksessa on hieman turhaa tavaraa: exons on symmetrinen, joten monet parit on esitetty tuloksessa kahdesti. Tämä voidaan ratkaista muuttamalla toista for-silmukkaa:\n\n# Initialize empty data frame for the pairs\nclose_pairs &lt;- data.frame()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  # Only check upper diagonal\n  for (j in seq(i, ncol(exons))) {\n    # Check if dissimilarity is below 4\n    if (exons[i, j] &lt; 4) {\n      # Add the pair as a new row to close_pairs\n      new_row &lt;- data.frame(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      close_pairs &lt;- rbind(\n        close_pairs,\n        new_row\n      )\n    }\n  }\n}\n\nclose_pairs\n\nNyt toisen silmukan läpi käymät j:n arvot riippuvat i:n arvosta. Tämä koodi käy läpi taulukon yläkolmion, eli diagonaalin yläpuolella olevat alkiot. Ensimmäisellä kierroksella j käy läpi arvot 1–7, seuraavalla kierroksella 2–7, sitten 3–7 jne. Vastaavasti voitaisiin myös käydä läpi alakolmio komennolla for(j in seq(1, i)).\nEmme kuitenkaan voi olla vieläkään tyytyväisiä tulokseen, sillä mukana ovat “parit”, joissa kumpikin laji on sama. Näistä emme luonnollisesti ole kiinnostuneita. Nämä parit voidaan poistaa esimerkiksi next-komennolla.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Toistorakenteet (loops)</span>"
    ]
  },
  {
    "objectID": "13-loops.html#iterointiin-puuttuminen-next-ja-break",
    "href": "13-loops.html#iterointiin-puuttuminen-next-ja-break",
    "title": "13  Toistorakenteet (loops)",
    "section": "13.4 Iterointiin puuttuminen: next ja break",
    "text": "13.4 Iterointiin puuttuminen: next ja break\nJoskus silmukan toimintaan on hyvä puuttua kesken suorituksen. Joskus yksi iteraatio halutaan sivuuttaa kokonaan, toisinaan taas halutaan keskeyttää koko silmukka. Näihin tarkoituksiin R:ssä ovat komennot next ja break.\nLisätään edelliseen esimerkkiin toiminto, joka ohittaa diagonaalilla olevat rivit, eli hyppää iteraation yli, jos i ja j ovat yhtä suuret. Käytetään tähän next-komentoa, joka ohjaa ohjelman suoraan seuraavaan iteraatioon sen silmukan suhteen, jonka sisällä komento on:\n\n# Initialize empty data frame for the pairs\nclose_pairs &lt;- data.frame()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  # Only check upper diagonal\n  for (j in seq(i, ncol(exons))) {\n    if (i == j) {\n       next\n    }\n    # Check if dissimilarity is below 4\n    if (exons[i, j] &lt; 4) {\n      # Add the pair as a new row to close_pairs\n      new_row &lt;- data.frame(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      close_pairs &lt;- rbind(\n        close_pairs,\n        new_row\n      )\n    }\n  }\n}\n\nclose_pairs\n\nNyt pääsimme eroon kaikista turhista pareista! Jos haluaisimme kaikkien parien sijaan etsiä vain ensimmäisen parin, jonka geenien etäisyys on alle 3, voisimme käyttää komentoa break, joka keskeyttää silmukan turhan suorittamisen haluamamme parin löydyttyä.\n\nclose_pair &lt;- c()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  # Only check upper diagonal\n  for (j in seq(i, ncol(exons))) {\n    if (i == j) {\n       next\n    }\n    # Check if dissimilarity is below 3\n    if (exons[i, j] &lt; 3) {\n      # Assign pair to close_pair and stop search\n      close_pair &lt;- c(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      break\n    }\n  }\n}\n\nclose_pair\n\nHUOM: Tämä ei kuitenkaan ole oikea pari: Jos exons datakehikkoa käydään läpi rivi kerrallaan, ensimmäinen pari, jonka arvo on alle 3 on Human ja Lemur, ei Mouse ja Gorilla. Mikä siis meni väärin? Kun kyse on näin pienestä aineistosta, voidaan mahdollisia ongelmia tutkia lisäämällä silmukoiden sisään print()-komentoja, jotka kertovat meille silmukan etenemisestä. Lisätään siis edelliseen silmukkaan rivi, joka tulostaa iteraatiomuuttujat i ja j jokaisella iteraatiolla, sekä rivi, joka tulostaa uuden parin, kun sellainen löytyy:\n\nclose_pair &lt;- c()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  # Only check upper diagonal\n  for (j in seq(i, ncol(exons))) {\n    # Monitor loop\n    print(c(i, j))\n    if (i == j) {\n      next\n    }\n    # Check if dissimilarity is below 3\n    if (exons[i, j] &lt; 3) {\n      # Assign pair to close_pair and stop search\n      close_pair &lt;- c(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      print(close_pair)\n      break\n    }\n  }\n}\n\nclose_pair\n\nNyt huomataan, että iteraatio etenee rivillä yksi neljänteen sarakkeeseen asti, ja löytää parin Human-Lemur, aivan kuten pitikin. Jostain syystä ohjelma siirtyy kuitenkin sen jälkeen toiselle riville. Tämä johtuu siitä, että break-komento katkaisee vain yhden for-silmukan kerrallaan. Jos haluamme katkaista myös ulomman silmukan, meidän tulee lisätä ulomman silmukan loppuun tarkastus, joka tarkastaa, onko pari jo löytynyt. Tämä voidaan testata esimerkiksi vektorin close_pairs pituuden avulla. Jos if-rakenteelle antaa pelkän luvun, luku tulkitaan arvoksi TRUE, jos se ei ole nolla.\n\nclose_pair &lt;- c()\n\n# Iterate over rows and columns\nfor (i in seq(1, nrow(exons))) {\n  # Only check upper diagonal\n  for (j in seq(i, ncol(exons))) {\n    if (i == j) {\n       next\n    }\n    # Check if dissimilarity is below 3\n    if (exons[i, j] &lt; 3) {\n      # Assign pair to close_pair and stop search\n      close_pair &lt;- c(\n        Species_1 = rownames(exons)[i],\n        Species_2 = colnames(exons)[j]\n      )\n      break\n    }\n  }\n  # Stop iterating if the pair has been found\n  if (length(close_pair)) {\n    break\n  }\n}\n\nclose_pair\n\nNyt koodimme toimii, kuten pitääkin!",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Toistorakenteet (loops)</span>"
    ]
  },
  {
    "objectID": "13-loops.html#apply-funktiot",
    "href": "13-loops.html#apply-funktiot",
    "title": "13  Toistorakenteet (loops)",
    "section": "13.5 Apply-funktiot",
    "text": "13.5 Apply-funktiot\nR:ssä käytetään silmukoiden lisäksi apply-funktioperheen funktioita, joilla voi käydä läpi datakehikkoja, matriiseja tai vektoreita ilman silmukoita. Joissain tapauksissa apply-funktiot ovat myös nopeampia kuin silmukat. Tästä syystä niitä näkee käytettävän paljon, ja varsinkin kokeneemmat R-ohjelmoijat käyttävät niitä usein silmukoiden sijaan. Tällä kurssilla näitä funktioita ei kuitenkaan tarvita. Tässä on annettu muutamia esimerkkejä, voit lukea lisää esimerkiksi DataCampin tutoriaalista\n\napply käy läpi matriisin/data framen rivit tai sarakkeet, ja ajaa jonkin funktion jokaiselle riville tai sarakkeelle. Alla oleva esimerkki standardoi kaikki R:n sisäisen datan trees sarakkeet siten, että sarakkeen arvoista vähennetään sarakkeen keskiarvo ja tulos jaetaan sarakkeen keskihajonnalla. Standardoinnin tarkoitus on, että kaikkien sarakkeiden keskiarvoksi saadaan 0, ja kaikilla on sama varianssi (ja keskihajonta) 1.\n\nhead(trees)\n\nscaler &lt;- function(x) {\n  scaled &lt;- (x - mean(x)) / sd(x)\n  scaled\n}\n\nscaled_trees &lt;- apply(X = trees, MARGIN = 2, FUN = scaler)\nscaled_trees &lt;- as.data.frame(scaled_trees)\nhead(scaled_trees)\n\nMARGIN-argumentilla määritetään, käydäänkö läpi rivit vai sarakkeet (1 = rivit, 2 = sarakkeet, moniulotteisten taulujen tapauksissa myös muut dimensiot ovat mahdollisia). HUOM: apply palauttaa aina matriisin tai vektorin. Jos tulos halutaan muuntaa takaisin datakehikoksi, täytyy se tehdä erikseen.\n\nTarkistetaan tulos laskemalla sarakkeiden keskiarvot ja varianssit. Tämä voidaan tehdä apply-funktiolla, tai käyttää sapply-funktiota, joka käy automaattisesti datakehikon sarakkeet, ja ajaa saman funktion sarakkeille kuten apply. \n\napply(scaled_trees, 2, mean)\nsapply(scaled_trees, var)\n\nHuomaa, että sarakkeiden keskiarvot eivät ole täsmälleen 0. Tämä johtuu R:n rajallisesta numeerisesta tarkkuudesta. Käytännössä itseisarvoltaan tätä luokkaa olevat arvot ovat nollia.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Toistorakenteet (loops)</span>"
    ]
  },
  {
    "objectID": "14-numerical_methods.html",
    "href": "14-numerical_methods.html",
    "title": "14  Numeeriset menetelmät",
    "section": "",
    "text": "14.1 Optimointi",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Numeeriset menetelmät</span>"
    ]
  },
  {
    "objectID": "14-numerical_methods.html#optimointi",
    "href": "14-numerical_methods.html#optimointi",
    "title": "14  Numeeriset menetelmät",
    "section": "",
    "text": "14.1.1 Yksi parametri\nAloitetaan yksinkertaisesta tapauksesta, jossa haluamme löytää funktion minimin yhden parametrin suhteen. Tällöin voidaan käyttää funktiota optimize.\n\noptimize(f, interval, ..., lower = min(interval), upper = max(interval),\n         maximum = FALSE, tol = .Machine$double.eps^0.25)\n\nEnsimmäinen argumentti f on funktio, jota minimoidaan sen ensimmäisen argumentin suhteen (jos funktiolla on muita argumenttej, joita tarvitaan, tulee ne antaa mukana optimize funktiokutsussa). Välin, jolta minimipistettä haetaa, voi ilmoittaa joku argumentilla interval, joka on vektori sisältäen välin päätepisteet. Vaihtoehtoisesti välin ylä- ja alaraja voidaan ilmoittaa erikseen argumenteilla lower ja upper, vastaavasti. Mikäli etsittäisiinkin minimin sijaan maksimia, tulisi asettaa myös argumentti maximum = TRUE.\nEtsitään nyt funktion \\(g(x) = x^2 + 2x + 2\\) minimi. Hakuvälin interval valitsemiseksi voimme esimerkiksi piirtää ensin funktion kuvaajan, jotta saamme suurin piirtein selville, missä minimi mahdollisesti sijaitsee:\n\ng &lt;- function(x) x^2 + 2*x -2\ncurve(g, xlim = c(-3, 1))\n\n\n\n\n\n\n\n\nKuvan perusteella minimiarvo saavutetaan pisteessä \\(x = -1\\). Käytetään nyt optimize funktiota:\n\noptimize(g, interval = c(-3, 1))\n\n$minimum\n[1] -1\n\n$objective\n[1] -3\n\n\nFunktion palauttmassa listassa alkio minimum ilmoittaa pisteen, jossa minimi saavutetaan. Alkio objective antaa tavoitefunktion (eli funktion f) arvon kyseisessä psiteessä.\n\n\n14.1.2 Useampi parametri\nMikäli funktiota halutaan minimoida useamman kuin yhden parametrin suhteen, voidaan käyttää funktiota optim.\n\noptim(par, fn, gr = NULL, ...,\n      method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),\n      lower = -Inf, upper = Inf,\n      control = list(), hessian = FALSE)\n\nEnsimmäinen argumentti par on vektori, joka antaa alkuarvot jokaiselle parametrille, jonka suhteen minimointia halutaan tehdä. Seuraava argumentti fn on minimoivata funktio, jonka ensimmäisen argumentin tulee vastata argumenttia par (vektori, jossa on yhtä monta alkiota). Vastaavasti kuten optimize-funktiossa, argumentit lower ja upper määrittävä alueen, jolta minimiä etsitään. Huomaa kuitenkin, että koska funktiolla fn on nyt useampi parametri, ovat lower ja upper myös vektoreita jotka ilmoittavat rajat jokaiselle parametrille erikseen. Alkuarvojen par on myös toteutettava mahdolliset rajoitteet. Argumentti method valitsee käytettävän optimointimenetelmän. Metelmistä riittää tietää tässä vaiheessa se, että jos optimointia halutaan tehdä käyttäen rajoitteita (lower ja upper), voidaan menetelmäksi valita “L-BFGS-B”, muuten voidaan käyttää oletusarvoa. Muista optim-funktion argumenteista ei tämän kurssin puitteissa tarvitse välittää.\nEtsitään funktion \\(f(x,y) = y^2\\exp(-0.5(y^2+x^2))\\) lokaali maksimi joukossa \\(-1 &lt; x &lt; 3\\), \\(-1 &lt; y &lt; 3\\). Annetaan alkuarvoiksi \\(x = 0.5\\) ja \\(y = 0.5\\). optim-funktio etsii oletusarvoisesti funktion minimiä, joten vaihtamalla funktion merkki etsitäänkin maksimia. Huomaa, että funktiolla f on vain yksi argumentti x, vaikka funktiolla \\(f\\) on kaksi argumenttia, \\(x\\) ja \\(y\\). Tämä johtuu siitä, että optim-funktion tapauksessa parametrien par on esiinnyttävä funktion argumenteissa vektorina. Vektorin x ensimmäinen alkio x[1] vastaa siis muuttujaa \\(x\\) ja toinen alkio x[2] vastaa muuttujaa \\(y\\). Tämä yleistyy useamman kuin kahden muuttujan funktioille, kun vektorin x pituutta kasvatetaan vastaavasti (esim. kolmas muuttuja \\(z\\) olisi x[3] jne.).\n\nf &lt;- function(x) -x[2]^2 * exp(-0.5 * (x[2]^2 + x[1]^2))\noptim(c(0.5, 0.5), f, lower = c(-1, -1), upper = c(3, 3), method = \"L-BFGS-B\")\n\n$par\n[1] -7.582426e-10  1.414214e+00\n\n$value\n[1] -0.7357589\n\n$counts\nfunction gradient \n       8        8 \n\n$convergence\n[1] 0\n\n$message\n[1] \"CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH\"\n\n\nFunktion palauttamassa tulosteessa par kertoo maksimipisteen koordinaatit. Ensimmäinen alkio kertoo maksimipisteen \\(x\\)-koordinaatin, ja toinen sen \\(y\\)-koordinaatin (huomioi erityisesti 1. alkion merkintätapa -7.582426e-10 joka tarkoittaa samaa kuin \\(-7.582426 \\cdot 10^{-10}\\), eli noin \\(0.00000000076\\), eli \\(x\\) koordinaatti on siis käytännössä \\(0\\)). value ilmoittaa löydettyä maksimipistettä vastaavan funktion arvon. Koska funktion merkki vaihdettiin maksimin etsimiseksi, on todellinen maksimiarvo siis löydetyn optimin vastaluku, eli \\(\\approx 0.7357589\\). Muut tulostukset ovat optimoinnin konvergenssiin liittyviä lisätietoja. Vaihtoehtoisesti maksimia voi etsiä suoraankin vaihtamatta funktion merkkiä antamalla optim-funktiolle lisäargumentti control = list(fnscale = -1).\nEtsitään vielä kolmen muuttujan funktion \\(h(x,y,z) = \\exp(-x^2-3x-7y^2+3y+z^3-2z-3)\\) lokaali maksimi joukossa \\(-2 &lt; x &lt; 2\\), \\(-3 &lt; y &lt; 3\\), \\(-3 &lt; z &lt; 0\\).\n\nh &lt;- function(x) exp(-x[1]^2 - 3*x[1] - 7*x[2]^2 + 3*x[2] + x[3]^3 - 2*x[3] - 3)\noptim(\n  c(0.5, 0.5, -0.5), h, lower = c(-2, -3, -3), upper = c(2, 3, 0), \n  method = \"L-BFGS-B\", control = list(fnscale = -1)\n)\n\n$par\n[1] -1.5000009  0.2142866 -0.8164968\n\n$value\n[1] 1.934968\n\n$counts\nfunction gradient \n      22       22 \n\n$convergence\n[1] 0\n\n$message\n[1] \"CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH\"\n\n\nKuten edellä, par ilmoittaa maksimipisteen koordinaatit. Maksimi saavutetaan siis pisteessä \\((x,y,z) \\approx (-1.5000009, 0.2142866, -0.8164968)\\) jolloin funktio \\(h\\) saa kohdan value ilmoittaman arvon \\(\\approx 1.934968\\). Nyt koska käytettiin argumenttia control = list(fnscale = -1), ei tuloksen merkkiä tarvitse vaihtaa.\nAlkuarvot funktioille optim ja optimize tulee valita siten, että rajoitteet ovat voimassa. Alkuarvojen valintaan on vaikea antaa yleispätevää ohjetta, ja usein onkin hyvä kokeilla eri arvoja ja verrata niillä saatuja tuloksia. Yhden ja kahden muuttujan tapauksissa löydettyjen optimipisteiden mielekkyyttä voi tarkastella esimerkiksi piirtämällä funktion kuvaajan annetussa joukossa.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Numeeriset menetelmät</span>"
    ]
  },
  {
    "objectID": "14-numerical_methods.html#funktion-juurten-etsintä",
    "href": "14-numerical_methods.html#funktion-juurten-etsintä",
    "title": "14  Numeeriset menetelmät",
    "section": "14.2 Funktion juurten etsintä",
    "text": "14.2 Funktion juurten etsintä\nFunktion juuria voidaan etsiä funktiolla uniroot.\n\nuniroot(f, interval, ...,\n        lower = min(interval), upper = max(interval),\n        f.lower = f(lower, ...), f.upper = f(upper, ...),\n        extendInt = c(\"no\", \"yes\", \"downX\", \"upX\"), check.conv = FALSE,\n        tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0)\n\nFunktion f juuria etsitään annetulta väliltä interval, sen ensimmäisen argumentin suhteen (jonka tulee olla skalaari). Halutun välin voi määrittää myös sen päätepisteinä käyttäen argumentteja lower ja upper. Muut uniroot-funktion argumentit eivät ole tämän kurssin kannalta oleellisia. Huomaa, että annetun välin tulee todella sisältää funktion juuri, muuten juurta ei luonnollisesti löydy.\nEtsitään funktion \\(w(x)=x^3-2x-5\\) juurta väliltä \\((-5,5)\\).\n\nw &lt;- function(x) { x^3 - 2*x - 5 }\nuniroot(w, interval = c(-5, 5))\n\n$root\n[1] 2.094528\n\n$f.root\n[1] -0.0002653143\n\n$iter\n[1] 9\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.103516e-05\n\n\nFunktion palauttamassa tulosteessa kohta root ilmoittaa löydetyn juuren. Mikäli juurta ei löydy annetulta väliltä, funktio antaa varoituksen. Kohta froot ilmoittaa funktion arvon löydetyssä pisteessä (funktion arvon ja nollan ero riippuu laskennan tarkkuudesta ja käytetystä menetelmästä).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Numeeriset menetelmät</span>"
    ]
  },
  {
    "objectID": "14-numerical_methods.html#numeerinen-integrointi",
    "href": "14-numerical_methods.html#numeerinen-integrointi",
    "title": "14  Numeeriset menetelmät",
    "section": "14.3 Numeerinen integrointi",
    "text": "14.3 Numeerinen integrointi\nR:n optimointityökaluihin kuuluu myös funktio integrate, jolla voi laskea useimpien funktioiden määrättyjä integraaleja.\n\nintegrate(f, lower, upper, ..., subdivisions = 100L,\n          rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol,\n          stop.on.error = TRUE, keep.xy = FALSE, aux = NULL)\n\nEnsimmäinen argumentti f on funktio, jota halutaan integroida. Argumentit lower ja upper määräävät integrointivälin, jonka päätepisteet voivat olla myös äärettömiä. Tällöin voidaan asettaa lower = -Inf tai vastaavasti upper = Inf..\nIntegroidaan funktiota \\(f(x) = x^2+3x-2\\) välin \\([-2,3]\\) yli.\n\npoly &lt;- function(x) { x^2 + 3*x - 2 }\nintegrate(poly, -2, 3)\n\n9.166667 with absolute error &lt; 2.8e-13\n\n\nIntegraalin arvo on siis noin \\(9.17\\).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Numeeriset menetelmät</span>"
    ]
  }
]